---------------------------------------------------
Anagram(words group like: cat, act)
---------------------------------------------------
49	Group Anagrams
[medium] sorted string in hashtable, hm<String, List<>>, or Arrays.hashCode(int[])  [TODO]

242	Valid Anagram
[easy] hashtable or sort string.  [TODO]




---------------------------------------------------
Array
---------------------------------------------------
53	Maximum Subarray,  max continous subarray.  condition on if local_max >0.
[easy]

54	Spiral Matrix.  4 loops of top,right,bottom and left side.
[medium to code]

55. Jump Game.  array operation. o(n), scan each item and exit early if possible.
[easy]

58, Length of Last Word. String operation. scan from last. o(n)
[very easy]

59, Spiral Matrix 2. 4 loops of top,right,bottom and left side.
[medium to code]

66. Plus One
[easy-medium]  find pattern. test case, 199, 999, 288, create new array only when like 999

73. Set Matrix Zeroes
[medium] o(1) space.  1. record if the first row/col should should set to 0, 2. then use them to store this row/col should be set to 0, 3. set every cell, 4. set first row/col according to step 1.

88. Merge Sorted Array
[easy] fill from the end of array.

118. Pascal's Triangle
[easy] find pattern. similar to tree level order traversal.

119. Pascal's Triangle II(find kth row, but only o(k) space)
[easy-medium] rolling array, scan from backward.

134. Gas Station
[easy-medium] greedy. read problem description carefully, because guaranteed solution
to be unique if failed at i, we can give up all index [0,i], start checking from i+1.

167. Two Sum II - Input array is sorted
[easy] two pointers. l++ and r--;

169. Majority Element
[easy-medium] counting number, count++ if the same; else count--; if count==0, ret=num[i], count=1
because majority > n/2, so it will always win with such counting.

189. Rotate Array
[easy] reverse 3 times. reverse(0,n-k-1); reverse(n-k,n-1); reverse(0,n-1)




---------------------------------------------------
Binary search
---------------------------------------------------
69. Sqrt(x)
[easy-medium] return left bound. negative number has not sqrt, use Long to handle overflow.

74. Search a 2D Matrix
[easy-medium] val = matrix[mid/col][mid%col]

33. Search in Rotated Sorted Array
[hard] 4 if conditions, compare num[mid] with num[left], and further compare target to num[left] and num[mid].

81. Search in Rotated Sorted Array II (duplicate in array)
[hard] similar to 33, left++ if num[left] = num[mid]. worst case o(n)

153. Find Minimum in Rotated Sorted Array
[easy-medium]  if(num[mid] < num[r]) r= mid; else l = mid+1; return num[l]  while(l<r)

154. Find Minimum in Rotated Sorted Array II(duplicate is allowed)
[medium] if(num[mid] == num[r]) r--;  else are the same as 153.

162. Find Peak Element ((i==0 || num[i] > num[i-1]) && ( i= num.length-1 || num[i] > num[i+1]))
[medium] if(i>0 && num[mid] < num[mid-1]) (search left) r=mid-1  , else (search right) l = mid+1






---------------------------------------------------
Binary Tree
---------------------------------------------------
94. Binary Tree Inorder Traversal
[easy-medium] left-root-right. iterative, use stack. push p to stack if p is not null then p=p.left,  else if p==null, store stack.pop().val, and then p = p.right. while(p!=null || !s.isEmpty)

144. Binary Tree Preorder Traversal
[medium] iteratively. [TODO]

145. Binary Tree Postorder Traversal
[hard] iteratively.  [TODO]

100. Same Tree
[easy] DFS. return true if p == null && q==null, false if p==null || q==null, if p.val == q.val return dfs(p.left, q.left) && dfs(p.right, q.right) else return false

101. Symmetric Tree
[easy-medium] DFS or BFS. DFS compare left.val == right.val && dfs(left.left, right.right) && dfs(left.right, right.left).   BFS, two queues, lq.push(left,right), rq.push(right,left).

102. Binary Tree Level Order Traversal
[easy] BFS use queue, store size of each level. DFS pass level as argument.

107. Binary Tree Level Order Traversal II (return bottom up result)
[easy] almost the same as 102, just change ret.add(list) to ret.add(0,list);

103. Binary Tree Zigzag Level Order Traversal
[medium] 1. could reverse odd number of list with 102 solution. Collections.reverse(res.get(i));   2. use two stacks.

104. Maximum Depth of Binary Tree
[easy] DFS.  1 + max(dfs(node.left), dfs(node.right)). if(node ==null) return 0;

105. Construct Binary Tree from Preorder and Inorder Traversal
[medium] DFS. dfs(int[] preoder, int preorder_start, int preorder_end, int[] inorder, int inorder_start, inorder_end) if(preorder_start>preorder_end) return null, if (preorder_start==preorder_end) return new TreeNode(preorder[preorder_start]); else build it and recursive on left and right.

106. Construct Binary Tree from Inorder and Postorder Traversal
[medium] DFS. similar to 105.

110. Balanced Binary Tree
[easy-medium] DFS, if node ==null, return 0.  left_height = dfs(node.left), if(left_height==-1) return -1 ...  return 1+ max(left_height, right_height).

111. Minimum Depth of Binary Tree
[easy-medium] DFS. if(node.left==null || node.right==null) return 1 + max(dfs(node.left), dfs(node.right)),  else return 1 + min(dfs(node.left), dfs(node.right))

112. Path Sum
[easy-medium] DFS. if(root == null) return false;  if(root.val == sum && root.left ==null && root.right == null) return true; return dfs(root.left, sum-root.val) || dfs(root.right, sum-root.val)

113. Path Sum II
[medium] DFS + backtracking. pass along ret and cur_list. return condition is the same as 112. cur_list.add(root.val); dfs(ret, root.left, cur_list, sum-root.val); cur_list.remove(root.val)
 ... the same goes for right node.

114. Flatten Binary Tree to Linked List
[medium-hard] Morris Algorithm?  [TODO]

116. Populating Next Right Pointers in Each Node
117. Populating Next Right Pointers in Each Node II
[medium] share the same BFS level order traversal solution. with extra line of: if(i<size-1) node.next = q.peek(); for this linking next node.

129. Sum Root to Leaf Numbers(sum of each path from root to leaf)
[medium] DFS. tail recursion.
if(node==null) return 0; ret = sum*10+node.val;
if(left==right==null) return ret; return dfs(node.left, ret) + dfs(node.right, ret)

199. Binary Tree Right Side View
[easy] BFS, level order traversal from right to left.




---------------------------------------------------
Binary Search Tree
---------------------------------------------------
96. Unique Binary Search Trees
[medium-hard] DP. catalan number. f(n) = f(0)*f(n-1) + f(1)*f(n-2) + ... + f(n-1)f(0)

95. Unique Binary Search Trees II
[medium-hard] DFS. foreach(start,n), left = (start,i-1), right=(i+1,n).

98. Validate Binary Search Tree
[easy-medium] DFS. pass along min, max value to validate. return false if root.val>=max || root.val <= min. then return dfs(root.left,min, root.val) && dfs(root.right,root.val, max).

108. Convert Sorted Array to Binary Search Tree
[easy] DFS. dfs(int[] a, int start, int end), if(start>end) return null. else build tree. mid = (left+right)/2  ...

109. Convert Sorted List to Binary Search Tree
[medium] 1. convert list to array.  2. two pointers find mid point each loop. 3. global pointer, very tricky, see 109 solution.



---------------------------------------------------
Bit Manipulation
---------------------------------------------------
89. Gray Code
[medium] f(n) += reverse(f(n-1)) + 2^(n-1), use list to represent f(n)

136. Single Number(one number appears once while others twice)
[easy] xor on all the elements.

137. Single Number II(one number appears once while others three times)
[medium] on every bit, the sum of each bit is 3*n + (0 or 1). and all numbers bit by bit and mod 3 is the result.

190. Reverse Bits(unsigned integer)
[easy] ret = ret<< 1 || (n & 1); n >>= 1

191. Number of 1 Bits
[easy] ret += (n & 1);  n >>= 1

201. Bitwise AND of Numbers Range
[easy-medium] find common bits between n and m. (still not sure why only n and m)

---------------------------------------------------
DFS/backtracking or BFS(better for shortest path)
---------------------------------------------------
46  Permutations
47  Permutations II (contains duplicates)

78  Subsets(distinct numbers)
[medium] add all cur_list to ret in loop, cur_list as backtrack.

90  Subsets II (contains duplicates)
[medium] add all cur_list to ret in loop, sort and skip duplicate when i>start && num[i-1]=num[i]


39  Combination Sum
40  Combination Sum II (can't reuse same element)
216 Combination Sum III
377 Combination Sum IV



77  Combinations
[medium] return when size==k. return part of the subsets problem. cur_list as backtrack.

79. Word Search (Is a word in matrix)
[medium] 4 recursive calls inside one function. need visited[][] as backtrack, conditional and boundary check.

93. Restore IP Addresses
[medium] extra in level parameter to record which level we are in, use it for termination. pruning code for IP address like 00, 01, early break.

127. Word Ladder
[medium-hard]  BFS. add all neighbor words to list, and check level by level.

126. Word Ladder II(find all the path) (worth revisit)
[hard]  BFS + backtracking. long code.

130. Surrounded Regions
[medium-hard] start from 4 sides and mark all neighbors(BFS) from 'O' to 'P',
then set all 'O' to 'X', all 'P' to 'O'.  long code.

133. Clone Graph
[medium-hard] copy itself and copy its neighbors, use hashmap to store {new_node_label, new_node},
and return new_node if encountered to avoid duplicate. recursively add its neighbors.

200. Number of Islands
[medium] DFS, for each cell, do DFS on adjacent cells, and mark them as visited.

207. Course Schedule (find cycle in a graph)
[medium-hard] find cycle in graph. [TODO]

210. Course Schedule II
[medium-hard] graph. [TODO]







---------------------------------------------------
DP
---------------------------------------------------
62. Unique Paths
[easy] dp[i][j] = dp[i-1][j] + dp[i][j-1]

63. Unique Paths II
[easy-medium]  rolling array.  dp[j] += d[j-1]  when j>0

64. Minimum Path Sum
[easy]  dp[j] = min(dp[j-1], dp[j]) + grid[i][j].  similar to 62, but use rolling array(o(m) space).

70, climb stairs. (either 1 step or 2 steps)
[easy-medium]   dp[i] = dp[i-2] + dp[i-1].  or c= a+b, a=b, b=c

91. Decode Ways
[medium] dp[i] = dp[i-1] + dp[i-2] if substring(i-1,i) and substring(i-2,i) is valid dp[0]=dp[1]=1

120. Triangle
[medium] bottom up DP, rolling array. dp[i] = min(dp[i], dp[i+1]) + matrix[i][j]

121. Best Time to Buy and Sell Stock
[easy-medium] greedy. minVal = min(minVal, a[i]);  ret = max(ret, a[i]-minVal);

122. Best Time to Buy and Sell Stock II(could buy and sell as much as possible.)
[easy-medium] greedy. add up all the positive difference between two days.

123. Best Time to Buy and Sell Stock III
[medium-hard] two-way DP. find max profit <= i, find max profit >= i. and combine them. ret = max(ret, left[i]+right[i])

139. Word Break(check if string can be segmented into a few words in a given dictionary)
[medium-hard] DFS will TLE.  use DP. DP, dp[i+1] = true if dp[j]==true && dict.contains(substring[j,i+1)) for j in [0,i]

140. Word Break II
[hard]  DP + DFS + backtracking. [TODO]

152. Maximum Product Subarray
[medium] DP or greedy. maxVal = max(maxVal, max(num*minVal, num*maxVal));  minVal = min(minVal, min(num*minVal, num*maxVal)); ret= max(ret, maxVal)

198. House Robber
[easy] dp[i] = max(dp[i-i], dp[i-2] + num[i]). or greedy, use even and odd.

213. House Robber II(house in a circle)
[medium] two times of DP, 1. remove head.  2. remove tail.

204. Count Primes
[easy-medium] if dp[i] is prime, set dp[i*j] = Not Prime, while j in[2,i*j<=n]; then count.

221. Maximal Square (time o(m*n), space(m*n), space can be reduced use rolling array and one variable)
[medium] if matrix[i][j] == '1':  dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])






---------------------------------------------------
Hash Table
---------------------------------------------------
166. Fraction to Recurring Decimal
[medium-hard] use hashtable to store visited number, and add brackets before it.

187. Repeated DNA Sequences
[easy-medium] hashtable on every length 10 string.

202. Happy Number
[easy] put calculated number in hashset to detect duplicate.

205. Isomorphic Strings
[easy-medium] two way hashtables.

217. Contains Duplicate(check duplicate integer in an array.)
[easy] hashset.

219. Contains Duplicate II(duplicate within k distance)
[easy] hashtable, value and idnex. check distance.

220. Contains Duplicate III
[medium-hard]  treeset? [TODO]








---------------------------------------------------
Linked List
---------------------------------------------------
61. Rotate List
[easy-medium] count node, tail -> head, move n - k steps, head = tail.next, tail.next = null  [TODO]

83. Remove Duplicates from Sorted List
[easy] skip next if equals. if ==, cur.next=cur.next.next, else cur = cur.next.

82. Remove Duplicates from Sorted List II
[medium] need dummy node to skip the first one. store duplicate value by checking cur.next.val == cur.next.next.val , and skip all duplicate if equals duplicate value.

86. Partition List
[medium] two dummy nodes as the start of each list, two p pointers points to current node will end up to the tail of each list.

206. Reverse Linked List
[easy-medium] iterative one. need pre, cur, next.

92. Reverse Linked List II
[medium] dummy node to solve first node issue. need extra pre_m, m_node to link head and tail. pre_m.next = pre, m_node.next=cur.  pre, cur, next for reversing node. m-- >1; n-- >1

141. Linked List Cycle
[easy] two pointers, slow and fast. while(fast!=null && fast.next != null) ...

142. Linked List Cycle II(find entrance of cycle)
[medium] once they meet, reset slow to head, and move them at the same pace, they will meet at the entrance.

143. Reorder List (1->2->3->4   ----->    1->4->2->3)
[medium] find mid point, and reverse the second half, and merge them.

147. Insertion Sort List
[medium] need dummy node.[TODO]

148. Sort List
[medium] merge sort. [TODO]

160. Intersection of Two Linked Lists
[easy-medium] subtract the length of two lists. the longer one moves the diff steps first.

203. Remove Linked List Elements
[easy] dummy node to handle first node or while loop to skip the first node.






---------------------------------------------------
Math
---------------------------------------------------
60, Permutation Sequence.
[medium to hard] math, k / (n-1)! for current number,  k%(n-1)! for next iteration.

168. Excel Sheet Column Title(convert base 10 to base 26)
[easy-medium] construct from right to left, use mod first then divide. n-- to solve non-zero issue.

171. Excel Sheet Column Number(convert base 26 to base 10)
[easy] sum = sum *26 + (s.charAt(i)- 'A' + 1); for(i in [0,n-1])

172. Factorial Trailing Zeroes
[easy] count number of 5s, equal trailing zeros. time o(log5)





---------------------------------------------------
Palindrome(DFS + backtracking or DP)
---------------------------------------------------
https://leetcode.com/articles/longest-palindromic-substring/#approach-5-manachers-algorithm-accepted    Manacher's Algorithm
5	Longest Palindromic Substring

9	Palindrome Number
[easy-medium], create div the same digits as number, use it to get left digit

125	Valid Palindrome
[easy-medium], consider case and special chars. two pointers start from left and right end.

131 Palindrome Partitioning
[medium-hard] DP to find all palindrome of sub-strings, DFS+backtracking.

132 Palindrome Partitioning II
[hard] DP cut[j] = min(cut[j], cut[i-1] + 1) inside a[i] == a[j] condition.  [TODO]

214	Shortest Palindrome
[hard] String, recursive. prefix, suffix and middle. [TODO]

234	Palindrome Linked List
[easy] o(n) space,  [medium] o(1) space. reverse first half list. [TODO]

266	Palindrome Permutation    (locked)
267	Palindrome Permutation II (locked)

336	Palindrome Pairs
[hard] hashtable + divide conquer. split each words str1 and str2, and check if isPal(str2) and reversed(str2) in map. [TODO]




---------------------------------------------------
Sort
---------------------------------------------------
179. Largest Number
[medium] custom sort base on String desc (330 before 303)
Collections.sort(list, new Comparator<Integer>(){
    public int compare(Integer a, Integer b){
        return (""+b+a).compareTo(""+a+b);
    }
});


215. Kth Largest Element in an Array
[medium] heap or quicksort.




---------------------------------------------------
Stack
---------------------------------------------------
71. Simplify Path
[medium] pop if it's "..", continue if it's '.', else push

150. Evaluate Reverse Polish Notation
[easy] if operand, pop twice and evaluate and push back, else push.

155. Min Stack
[easy-medium] two stacks. one for regular pop, push and top. another to store min_values, push only when incoming is smaller than top, only pop when val = top.
used the trick of stack's top always be the smallest until a smaller comes after.

173. Binary Search Tree Iterator
[medium] push all left node to stack until the left most. when pop, if node.right!=null, push all its left. the reason it's o(1) time, because each element is visited only once.


---------------------------------------------------
String
---------------------------------------------------
67. Add Binary
[easy-medium]  two pointers in one loop, while they >=0

151. Reverse Words in a String
[easy-medium] trim().split(" +") to String[]. and reverse it.  or manual scan word, and reversely append word.

165. Compare Version Numbers
[easy-medium] problem says 1.22 > 1.3 because 22 > 3. sum digits up and compare.



---------------------------------------------------
Two pointers(or Three pointers)
---------------------------------------------------
75. Sort Colors
[easy-medium] three pointers. if 0, swap(i++,left++), if 2, swap(i,right--), else i++; while(i<=right)

26. Remove Duplicates from Sorted Array
[easy-medium] i as the end of array, compare it with num[j], if equal continue j and skipped num[j],
else num[++i] = nums[j],  return i+1

80. Remove Duplicates from Sorted Array II
[easy-medium] similar to 26, compare with num[i-1] rather than num[i]. j starts from 2.

209. Minimum Size Subarray Sum(N203 in my Java code)
[medium] sliding window. window [i,j] >= sum; while([i++,j]>=sum, ret= min(ret, j-i+1))




---------------------------------------------------
Trie
---------------------------------------------------
208. Implement Trie (Prefix Tree)
[medium-hard] class Trie{Trie[] children; boolean isEnd;}

211. Add and Search Word - Data structure design
[medium-hard] BFS on trie of wildcard(.)


