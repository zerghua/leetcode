10/16/2016 on N389
11/2/2016 backwards added N419.
11/3/2016 backwards added N401.
11/4/2016 backwards added N389.
11/5/2016 backwards added N379.
11/6/2016 all added(traced back to N300).

---------------------------------------------------
Anagram(words group like: cat, act) (reviewed on 9/28/2016, 10/27/2016, 11/30/2016)
---------------------------------------------------
49. Group Anagrams(important)(real question)
[medium] hashmap<String, list>  or hashmap<int, list>.
1. Arrays.sort(word.toCharArray()) and String(char[]) as key in map.   o(nlogn) time
2. foreach char[c-'a']++; String(char[]) as key in map.  o(n) time


242. Valid Anagram(is valid anagram of two strings.)
[easy] hashtable or sort string.


If a String Contains an Anagram of Another String
// sliding window + hashmap. similar to N159 N340 and N49
// assume all english chars.
public boolean isContainAnagram(String s, String t){
    int m = s.length(), n = t.length();
    if(m < n) return false; // s should be longer than t
    char[] a= new char[26];
    for(char c: t)a[c - 'a']++;
    String key = new String(a);

    char[] b= new char[26];
    for(int i=0, left=0 ;i<m;i++){
        b[s.charAt(i) - 'a']++;
        if(i>=n-1){
            if(key.equals(new String(b))) return true;
            b[s.charAt(left++) - 'a']--;
        }
    }
    return false;
}


---------------------------------------------------
Array (reviewed on 9/29/2016, 10/27/2016)
// for array problem, if sort is not efficient enough, use hash table or two pointers/sliding window
// if sorted or adjacent/continuous graph , it's usually binary search.
---------------------------------------------------
31. Next Permutation(hard on find the pattern)
[medium-hard] [TODO]

48. Rotate Image(rotate 90 degree of matrix)
[medium] extra space easy, ret[j][n-1-i] = matrix[i][j];  inplace, 4-way rotation. or transpose and flip(TODO).

54	Spiral Matrix(return array of spiral order, outer-->inner clockwise)(real question)
[medium] 4 loops of top,right,bottom and left side.

59, Spiral Matrix II(generate spiral n^2 matrix)
[medium] 4 loops of top,right,bottom and left side.


66. Plus One(to an array of digits)(real question)
[easy-medium]  find pattern. test case, 199, 999, 288, create new array only when like 999
for(int i=digits.length-1;i>=0;i--){
    if(digits[i] != 9 ){
        digits[i]++;
        return digits;
    }
    digits[i]=0;
}
// create new array if comes to here. like 999+1, return 1000
int[] ret = new int[digits.length+1];
ret[0]=1;
return ret;


73. Set Matrix Zeroes(require o(1) space.)
[medium] 1. record if the first row/col should should set to 0, 2. then use them to store this row/col should be set to 0,
3. set every cell, 4. set first row/col according to step 1.

88. Merge Sorted Array
[easy] fill from the end of array.

118. Pascal's Triangle(generate it. [1],[1,1],[1,2,1],[1,3,3,1]...)
[easy] find pattern. similar to tree level order traversal. use previous list to construct current list.

119. Pascal's Triangle II(find kth row, but only o(k) space)
[easy-medium] rolling array, scan from backward.
Integer[] row = new Integer[rowIndex+1];
Arrays.fill(row, 1);
for(int i=1; i<=rowIndex;i++){
    for(int j= i-1;j >= 1;j--){  // only works if backward
        row[j] += row[j-1];
    }
}
return Arrays.asList(row);

169. Majority Element(majority > n/2)
[easy-medium] counting number, count++ if the same; else count--; if count==0, ret=num[i], count=1
because majority > n/2, so it will always win with such counting.
int majorElement=nums[0];
int count=1;
for(int i=1;i<nums.length;i++){
    if(majorElement == nums[i]) count++;
    else count -- ;

    if(count == 0) {
        majorElement = nums[i];
        count=1;
    }
}
return majorElement;

229. Majority Element II(find out numbers exists times > n/3) Boyer_Moore_majority_vote_algorithm
[medium-hard] 2 variables to hold number, 2 counters.

189. Rotate Array
[easy] reverse 3 times. reverse(0,n-k-1); reverse(n-k,n-1); reverse(0,n-1)

228. Summary Ranges(given [0,1,2,4,5,7], return ["0->2","4->5","7"])(interesting)
[medium] maintain start index.
if num[i]-num[i-1] >1, construct list(start,i-1); start=i;  (may overflow num[i]-num[i-1])(corner case last one)
    for(int i=1; i<=nums.length;i++){
        if(i == nums.length || nums[i] != nums[i-1]+1){
            if(i-1 == start) ret.add(""+ nums[i-1]); // case when last one is single.
            else ret.add(nums[start] + "->" + nums[i-1]);
            start = i;
        }
    }


238. Product of Array Except Self(can't use divide, require o(n) time) (tricky, kind of DP.)
[medium] two pass from left and right. product of all its left and right.
1st pass: ret[i] = num[i+1]*ret[i+1]; 2ed pass: ret[i] *= left_sum; left_sum *= nums[i];

274. H-Index[TODO]
[medium] sort o(nlogn), return i if reversed sorted a[i]<=i;
hashtable o(n) time, count each a[i], store in stat[], from [n,0) sum+=stat[i]; return i if sum>=i;

275. H-Index II(arrays is sorted, require logn)
[medium] binary search.
while(left<=right){
    int mid = (right-left)/2 + left;
    if(citations[mid] ==  n - mid) return n-mid;
    else if(citations[mid] < n -mid) left = mid+1;
    else right = mid-1;
}
return n-left;

289. Game of Life(require in-place, smart!!!)
[medium] use second bit in int to store next state. 0 --> 00 or 10,  1--> 01 or 11.

324. Wiggle Sort II[TODO]
[medium] sort and rearrange. [NOT easy to understand.]

334. Increasing Triplet Subsequence(3 increasing variables exists or not)
[easy-medium] a,b variables; each n compare with them and update. return true if larger than both

373. Find K Pairs with Smallest Sums[TODO]
[medium] heap time o(n*n).  can be optimized.

378. Kth Smallest Element in a Sorted Matrix
[medium] heap. put the first row in heap, poll from heap, push back with row++;

393. UTF-8 Validation
[medium] find pattern.

412. Fizz Buzz
[easy] very easy.

414. Third Maximum Number
[easy-medium] very tricky to find distinct third largest.
if( (first != null && first == n) || (second!= null && second == n) ||
(third!=null && third == n)) continue;  //to skip duplicate

442. Find All Duplicates in an Array
[medium] similar to 448. inverse the number of index.[TODO] need to think about how to explain it.

448. Find All Numbers Disappeared in an Array
[easy-medium] very tricky. similar to N442.

463. Island Perimeter
[easy-medium] island*4 - neighbour*2; only count right and down neighbours.



---------------------------------------------------
Binary search(reviewed on 9/28/2016, 10/27/2016, 12/1/2016)
(
1. regular BS is while(left<=right), and has early return
2. special case like find min in rotated array, while(left<right) return nums[left]; compare with right
3. special case like two recursion call in == condition to find index range of target
4. special case to store middle result ret while recurse, like N69.sqrt and N278.badVersion
)
---------------------------------------------------
33. Search in Rotated Sorted Array
[hard-medium] 4 if conditions, compare num[mid] with num[left],
further compare target to num[left] and num[mid].

81. Search in Rotated Sorted Array II (duplicate in array)
[hard-medium] similar to 33, left++ if num[left] = num[mid]. worst case o(n)

153. Find Minimum in Rotated Sorted Array(real question)
[easy-medium]  [only exception of left<right rather than left<=right], because it's return num[left]
if(num[mid]< num[r]) r= mid(not mid-1, because it can be the min);
else l = mid+1; return num[l]  while(l<r)

154. Find Minimum in Rotated Sorted Array II(duplicate is allowed)(real question)
[hard-medium] if(num[mid] == num[r]) r--;  else are the same as 153.

34. Search for a Range(interesting)(can only do recursion, because there are two recursive call in == condition)
[medium] more code when ==; update ret[0] and ret[1]; two direction recursion dfs(start, mid-1); dfs(mid+1,end)

35. Search Insert Position(real question)
[medium-easy] regular binary search, insertion position is the left bound; return left;

50. Pow(x, n) (real question)(interesting)
[medium] binary search.
if(n==0) return 1;
if(n<0) return 1/pow(x, -n); // if n = Int.MIN_VALUE, will overflow. then, 1/x*pow(x,-(n+1))
int ret = pow(x, n/2);
if(n%2==0) return ret*ret;
else return ret*ret*x;

69. Sqrt(x) (interesting)
[easy-medium] negative can't be sqrt. regular BS, but store temp ret in condition. use long to handle overflow.
int left=1, right=x, ret=1;
while(left<=right){
    int mid = (right-left)/2 + left;
    int tmp = (long) mid*mid;
    if( tmp== x) return mid;
    else if(tmp < x) {ret = mid; left=mid+1;}
    else right = mid-1;
}
return ret;


74. Search a 2D Matrix(can be converted to 1D row by row.)
[easy-medium] l=0, r=row*col-1; midVal = matrix[mid/col][mid%col],  time o(log(m+n))

240. Search a 2D Matrix II(sorted by rows and cols)
[easy-medium] o(m+n). start on top right point, row=0, col=col_size-1; row++ or col--;
time can also be o(mlogn) or o(nlogm)

162. Find Peak Element (tricky but interesting)
[medium] return mid if(mid==0 || num[mid] > num[mid-1]) && ( mid= num.length-1 || num[mid] > num[mid+1])
if(mid>0 && num[mid] < num[mid-1]) (search left) r=mid-1  , else (search right) l = mid+1

278. First Bad Version(real question)
[easy] if (mid is isBad){ret = mid; r =mid-1}; else l=mid+1;

374. Guess Number Higher or Lower
[easy] regular binary search.


---------------------------------------------------
Binary Tree(reviewed on 9/30/2016, 10/28/2016)
---------------------------------------------------
94. Binary Tree Inorder Traversal
[easy-medium] left-root-right. iterative, use stack.
push p to stack if p is not null then p=p.left,  else if p==null, store stack.pop().val,
then p = p.right. while(p!=null || !s.isEmpty)

144. Binary Tree Preorder Traversal
[medium] iteratively. [TODO]

145. Binary Tree Postorder Traversal
[hard] iteratively.  [TODO]

100. Same Tree
[easy] boolean = DFS(node1, node2)
return true if p == null && q==null, false if p==null || q==null; if p.val == q.val
return dfs(p.left, q.left) && dfs(p.right, q.right) else return false

101. Symmetric Tree
[easy-medium] DFS or BFS. similar to N100.
DFS compare left.val == right.val && dfs(left.left, right.right) && dfs(left.right, right.left).
BFS, two queues, lq.push(left,right), rq.push(right,left).

102. Binary Tree Level Order Traversal
[easy] BFS use queue, store size of each level. DFS solution passes level as argument.

107. Binary Tree Level Order Traversal II (return bottom up result)
[easy] almost the same as 102, just change ret.add(list) to ret.add(0,list);

103. Binary Tree Zigzag Level Order Traversal
[medium] 1. could reverse odd number of list with 102 solution. Collections.reverse(res.get(i));
2. use two stacks.

116. Populating Next Right Pointers in Each Node(perfect binary tree)
117. Populating Next Right Pointers in Each Node II(any binary tree)
[medium] use BFS level order traversal solution.
One extra line of: if(i<size-1) node.next = q.peek(); (linking the next node if not the last.)

199. Binary Tree Right Side View
[easy] BFS, level order traversal from right to left.

104. Maximum Depth of Binary Tree(real question)(max of max)
[easy] int = DFS(node)  bottom-up DFS.
if(node ==null) return 0; return 1 + max(dfs(node.left), dfs(node.right));

111. Minimum Depth of Binary Tree(real question)(min of min, if one child is null then max of min)
[easy-medium] int = DFS(node)(one more case than 104 max depth.)  bottom-up DFS.
if(node.left==null || node.right==null) return 1 + max(dfs(node.left), dfs(node.right)),
return 1 + min(dfs(node.left), dfs(node.right))
BFS solution works well for highly unbalanced tree.

110. Balanced Binary Tree(height-balanced tree: every node's subtree diff <= 1)(real question)(interesting)
[easy-medium] BF o(n^2), for each node, check left and right diff. bottom-up DFS.
bottom-up DFS. similar to N104 max depth of binary tree.
public int getHeight(TreeNode root){
    if(root == null) return 0;
    int left = getHeight(root.left);
    if(left == -1) return -1;
    int right = getHeight(root.right);
    if(right ==-1 || Math.abs(left-right) > 1) return -1;
    return 1+ Math.max(left, right);
}

124. Binary Tree Maximum Path Sum(find max sum from any node to any node, not need to across root)(very interesting)
[hard-medium] DFS bottom up, partial max, and global max. int = DFS(node) bottom-up DFS.
int global_max=Integer.MIN_VALUE;
int DFS(node){
    if(node == null) return 0;
    int left_sum = DFS(node.left);
    int right_sum = DFS(node.right);
    int partial_sum = Math.max(node.val, Math.max(node.val + left_sum,  node.val + right_sum));
    global_max = Math.max(global_max,  Math.max(partial_sum, node.val+left_sum+right_sum));
    return partial_sum;
}


105. Construct Binary Tree from Preorder and Inorder Traversal
[medium]dfs(int[] preoder, int preorder_start, int preorder_end, int[] inorder, int inorder_start, inorder_end)
if(preorder_start>preorder_end) return null,
if (preorder_start==preorder_end) return new TreeNode(preorder[preorder_start]);
else build it and recursive on left and right.

106. Construct Binary Tree from Inorder and Postorder Traversal
[medium] DFS. similar to 105.

112. Path Sum(return if sum of any root to leaf path == val)
[easy-medium] boolean = DFS(node, val)
if(root == null) return false;
if(root.val == sum && root.left ==null && root.right == null) return true;
return dfs(root.left, sum-root.val) || dfs(root.right, sum-root.val)

113. Path Sum II(return all path == val)
[medium] DFS + backtracking.  void = dfs(node, val, ret, list)
pass along ret and cur_list. return condition is the same as 112.
cur_list.add(root.val); dfs(ret, root.left, cur_list, sum-root.val); cur_list.remove(root.val)
 ... the same goes for right node.

437. Path Sum III(find count of path sum to a target, can start from any node, but only downwards.)
[easy-medium] return dfs(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
dfs(node, sum){
    if(node== null) return 0;
    return (node.val == sum? 1:0) + dfs(node.left, sum-node.val) + dfs(node.right, sum-node.val);
}

129. Sum Root to Leaf Numbers(sum of each path from root to leaf)
[medium] int = DFS(node, val)
public int dfs(TreeNode node, int sum){
    if(node == null) return 0;
    int ret = sum*10 + node.val;
    if(node.left == null && node.right==null) return ret;
    return dfs(node.left, ret) + dfs(node.right, ret);
}

257. Binary Tree Paths(return all root to leaf path)(real question)(facebook)
[easy-medium] DFS + backtracking. similar to N129. void = DFS(node, ret, string)

114. Flatten Binary Tree to Linked List
[medium-hard] Morris Algorithm?  [TODO]

222. Count Complete Tree Nodes (require o(nlogn) time) (interesting)
[medium] binary search.  int = dfs(node)
count left_height; count right_height; if equal return (1<<left_height)-1;
else recur(root.left) + recur(root.right) +1;

226. Invert Binary Tree(swap left and right)(interesting)
[easy-medium] node = DFS(node), bottom up.
if(root == null) return root;
else {
    TreeNode tmp = invertTree(root.left);
    root.left = invertTree(root.right);
    root.right = tmp;
    return root;
}

236. Lowest Common Ancestor of a Binary Tree(real question)(Google/Microsoft)
[medium] top-bottom. kind of similar to N226.
if left and right children contains each of q and p, then return current node;
else if one of them is returned, then that one is the result.
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if(root == null || root == p || root == q) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if(left != null && right!=null) return root;
    return right == null? left: right;
}

307. Range Sum Query - Mutable(real question)(google)(must)
[medium-hard] segment tree. [TODO]

331. Verify Preorder Serialization of a Binary Tree
[medium] diff = outdegree - indegree = 1. each node count--; if not leaf, count+=2;
public boolean isValidSerialization(String preorder) {
    String[] arr = preorder.split(",");
    int count = 1;
    for(String s: arr){
        if(--count <0) return false;
        if(!s.equals("#")) count+=2;
    }
    return count == 0;
}

156. Binary Tree Upside Down(VIP)(linkedin phone)(interesting)
[medium] bottom-up approach. return dfs(root, null);
    public TreeNode dfs(TreeNode node, TreeNode parent){
        if(node == null) return parent; // return left-most node
        TreeNode root = dfs(node.left, node);
        node.left = (parent == null)? null: parent.right;
        node.right = parent;
        return root;
    }


404. Sum of Left Leaves
[easy-medium] DFS.

---------------------------------------------------
Binary Search Tree(reviewed on 9/30/2016, 10/28/2016)
---------------------------------------------------
96. Unique Binary Search Trees(return how many unique trees.)
[medium-hard] DP. catalan number. f(n) = f(0)*f(n-1) + f(1)*f(n-2) + ... + f(n-1)f(0)
public int numTrees(int n) {
    int[] catalan = new int[n+1];
    catalan[0]=1;
    for(int i=1; i<=n; i++){
        for(int j=0;j<i;j++){
            catalan[i] += catalan[j] * catalan[i-j-1];
        }
    }
    return catalan[n];
}


95. Unique Binary Search Trees II(generate all unique trees)(interesting)
[medium-hard] DFS. foreach(start,n), left = (start,i-1), right=(i+1,n).
public List<TreeNode> generateTrees(int start, int end) {
    List<TreeNode> ret = new LinkedList<>();
    if(start > end){
        ret.add(null);
        return ret;
    }

    for(int i=start; i<=end; i++){
        List<TreeNode> lefts= generateTrees(start, i-1);
        List<TreeNode> rights= generateTrees(i+1, end);

        for(TreeNode left: lefts){
            for(TreeNode right: rights){
                TreeNode node = new TreeNode(i);
                node.left = left;
                node.right = right;
                ret.add(node);
            }
        }
    }
    return ret;
}


98. Validate Binary Search Tree(real question)(interesting)
[easy-medium]
1. DFS. pass along min, max value to validate. Can pass null to Integer to avoid overflow.
public boolean isValidBST(TreeNode node, double min, double max){
    if(node == null) return true;
    if(node.val >= max || node.val <= min) return false;
    return isValidBST2(node.left, min, node.val) && isValidBST2(node.right, node.val, max);
}
2. in-order traversal, compare preNode and curNode isMonotonicIncreasing, like N109 convert list to BST.


108. Convert Sorted Array to Binary Search Tree(real question)(interesting)
[easy] node = DFS(int[], left_index, right_index) (divide and conquer)
public TreeNode sortedArrayToBSTHelper2(int[] nums, int left, int right){
    if (left > right) return null;
    int mid = left + (right - left)/2;
    TreeNode node = new TreeNode(nums[mid]);
    node.left = sortedArrayToBSTHelper(nums, left, mid - 1);
    node.right = sortedArrayToBSTHelper(nums, mid + 1, right);
    return node;
}

109. Convert Sorted List to Binary Search Tree(real question)(follow up of N108)
[medium] 1. convert list to array.  2. two pointers find mid point each loop.
3. global pointer, very tricky, see 109 solution. (bottom-up)  node = dfs(node, start_int, end_int)
private ListNode node ;
public TreeNode buildBST(int start, int end){
    if(start > end) return null;
    int mid = (end-start)/2 + start;
    TreeNode left = buildBST(start, mid-1);
    TreeNode root = new TreeNode(node.val);
    node = node.next;
    TreeNode right = buildBST(mid+1, end);
    root.left = left;
    root.right = right;
    return root;
}


230. Kth Smallest Element in a BST  [favorite]
[medium] recursively count current node.
if k == count return; else if count > k, dfs(root.left,k); else dfs(root.right, k-count);
or iteratively in-order traversal.

235. Lowest Common Ancestor of a Binary Search Tree
[easy] return if p < node.val < q. else recur left or right.




---------------------------------------------------
Bit Manipulation(reviewed on 10/27/2016)
---------------------------------------------------
29. Divide Two Integers
[medium] not sure. [TODO]

371. Sum of Two Integers
[easy-medium] [TODO]  not sure why.

89. Gray Code(interesting)
[medium] f(n) += reverse(f(n-1)) + 2^(n-1), use list to represent f(n)

136. Single Number(one number appears once while others twice)(real question)
[easy]
1. map<num, count>, two passes. o(n) space
2. hashset<num>, remove char if exist. one pass. o(n) space
3. o(1) space and one pass. xor on all the elements.

[follow up](all exists twice except two, return those two)(interesting)
[medium] divide and conquer.
first pass, c ^= each item in array.
find any one bit in C that is 1 and store it, separate array to two groups(based on 0 and 1 on that bit)
xor all item in each group will get you those two int.

137. Single Number II(one number appears once while others three times)(real question)
[medium] on every bit, the sum of each bit is 3*n + (0 or 1). each bit mod 3 is the result.

268. Missing Number(for [o,n] range, only one is missing, index in range [0,n-1])
[easy-medium] xor.  a^b^b = a.  ret = n(important); for i in [0,num.length) ret = ret ^ index ^ num[index]

190. Reverse Bits(unsigned integer) (follow up, hashtable to handle visited ones.)
[easy] ret = 0;
for(int i=0;i<32;i++){
    ret = ret<< 1 || (n & 1); n >>= 1  // the first bit is 0, so ok.
}

191. Number of 1 Bits
[easy] ret += (n & 1);  n >>= 1

201. Bitwise AND of Numbers Range(interesting) in range [m,n]
[easy-medium] count left common bits between m and n. return m<<count. write an example will understand.

397. Integer Replacement
[medium] matters on last two binary digits, and special case on 3.

405. Convert a Number to Hexadecimal(interesting)
[easy-medium] ret.insert(0, hex[num & 15]);

421. Maximum XOR of Two Numbers in an Array
[medium-hard] [TODO] figure out how this works.


---------------------------------------------------
Design(reviewed on 10/27/2016)
---------------------------------------------------
173. Binary Search Tree Iterator(next() return smallest in BST)(interesting)(stack)
[medium] push all left node to stack until the left most.
when pop, if node.right!=null, push all its left. It's o(1) time, because each element is visited only once.

284. Peeking Iterator(existing functions are iterator.next and iterator.hasNext; add a peek function)
[medium] the key is to cache(save) next element with element and isPeeked variables.

341. Flatten Nested List Iterator(interesting)(how to use polymorphism)
[medium] flatten nested list to an arraylist.
void = dfs(List<NestedInteger> nestedList){
    for(NestedInteger e: nestedList){
        if(e.isInteger()) ret.add(e.getInteger());
        else dfs(e.getList());
    }
}

385. Mini Parser(interesting)(constructed NestedInteger from String)
[medium-hard] stack to store each object.
if '[', add obj to stack,  if ',' || ']', add number to stack.peek() object, if ']', pop stack.

355. Design Twitter
[medium-hard] [TODO] a few hashmap, hashset and priorityQueue.

// Trie
208. Implement Trie (Prefix Tree)
[medium-hard] class Trie{Trie[] children; boolean isEnd;}

211. Add and Search Word - Data structure design
[medium-hard] BFS on trie of wildcard(.)

379. Design Phone Directory(VIP)
[medium]

380. Insert Delete GetRandom O(1)
381. Insert Delete GetRandom O(1) - Duplicates allowed
[hard]


---------------------------------------------------
DFS/backtracking or BFS(better for shortest path)(reviewed on 10/3/2016 - 10/4/2016)
---------------------------------------------------
17. Letter Combinations of a Phone Number(return all possible letter combinations that the number could represent)
[medium] void = DFS(ret, cur_list, digits_string, start_int, map)
hashmap to map number and chars. DFS on each char.
String[] map = {"", "*", "abc", "def", "ghi", "jkl","mno", "pqrs", "tuv","wxyz"};

22. Generate Parentheses(given int n, return all combinations of well-formed parentheses)(interesting)
[medium] void = DFS(ret, cur_string, left_int, right_int)
return if left< right; add to ret if left==0 && right==0;
two DFS in func: dfs(cur+"(", left-1, right;  dfs(cur+")", left, right-1);

46. Permutations(Given a distinct collection of numbers, return all possible permutations)
[medium] void = DFS(ret, cur_list, num_array, used_array)

47. Permutations II (contains duplicates, return unique permutation, no duplicate set.)
[medium] void = DFS(ret, cur_list, num_array, used_array)
Arrays.sort(num_array);
if(i>0 && num[i]==num[i-1] && !used[i-1]) continue; (think about why it's !used[i-1] for like set(1,1,2))

78. Subsets(Given a set of distinct integers, nums, return all possible subsets)
[medium] void = DFS(ret, cur_list, num_array, start_int)

90. Subsets II (contains duplicates)  [1,1,2]
[medium] void = DFS(ret, cur_list, num_array, start_int)
Arrays.sort(num_array);
if(i>start && num[i]==num[i-1]) continue;

// difference on permutation and subset, for example [1,2,3]:
permutation:   [1,2,3], [2,1,3] ...
subset:        [1,2,3], [2,3], [3] ...      subset remains original sequence.

// the reason why using start+1 or start is to avoid duplicate of (1,2) and (2,1).
// only permutation will need that, so it need an used_array.


39. Combination Sum(find all unique combinations in C where the candidate positive numbers sums to T) like set [2, 3, 6, 7] and target 7
[medium] void = DFS(ret, cur_list, num_array, cur_target, start_int);
dfs(ret, cur_list, num_array, cur_target-num_array[start_int], start_int);
Arrays.sort(num_array);

40. Combination Sum II (can use only once for each element. 39 the same number can be used multiple times.)
[medium] void = DFS(ret, cur_list, num_array, cur_target, start_int);
dfs(ret, cur_list, num_arary, cur_target-num_array[start_int], start_int+1);
Arrays.sort(num_array);

216. Combination Sum III(given number [1,9], each can use only once, return all possible k numbers sum to n)
[medium] void = DFS(ret, cur_list, k_int, n_int, start_int)
for(int i=start;i<=9;i++){}

377. Combination Sum IV(return number of possible results with the same proble of N216)(tricky, tailored for interview, (1,2) and (2,1) both are valid)
[medium] DP.  dp[i+n] += dp[i] if (i+n<=target)

77  Combinations(return all combinations of k numbers out of n, (1,2) and (2,1) are duplicate)
[medium] void = DFS(ret, cur_list, k_int, n_int, start_int)  for(int i=start;i<=n;i++)
return when size==k. return part of the subsets problem. similar to

79. Word Search (Is this word exists in matrix)
[medium] boolean = DFS(matrix, word_string, start_int, i_int, j_int, visited_matrix)
4 recursive calls inside one function. need visited[][] as backtrack, conditional and boundary check.

93. Restore IP Addresses(given a string of digits, return all possible valid IP address.)
[medium] void = DFS(ret, cur_list, word_string, start_int, level_int)
for(int i=start+1; i<=start+3 && i<word.length;i++){}
extra in level parameter to record which level we are in, use it for termination.
pruning code for IP address like 00, 01, early break.

127. Word Ladder(TODO)
[medium-hard]  BFS. add all neighbor words to list, and check level by level.

126. Word Ladder II(find all the path) (worth revisit)(TODO)
[hard]  BFS + backtracking. long code.

130. Surrounded Regions(matrix with 'X' and 'O', set surrounded 'O' to 'X')
[medium-hard] start from 4 sides and mark all neighbors(BFS) from 'O' to 'P',
then set all 'O' to 'X', all 'P' to 'O'.  long code.

133. Clone Graph(each node's label is unique)(tricky but interesting)(real question)
[medium]  NewNode = DFS(node, map<node, newNode>), simiar to N138 clone random linked list
return new_node if encountered to avoid duplicate, copy itself and copy its neighbors, recursively add its neighbors.
public UndirectedGraphNode dfs(UndirectedGraphNode node,
                               HashMap<Integer,UndirectedGraphNode> map){
    if(map.containsKey(node)) return map.get(node); // return copy of node
    UndirectedGraphNode newNode = new UndirectedGraphNode(node.label);
    map.put(node, newNode);
    for(UndirectedGraphNode n: node.neighbors){
        newNode.neighbors.add(dfs(n, map));
    }
    return newNode;
}

200. Number of Islands(matrix with 1(land) and 0(water), count number of islands, assume edges are water)(interesting)
[medium] void = DFS(matrix, i_int, j_int, visited_matrix)
DFS, for each cell(if not visited, islands++), do DFS on adjacent cells, and mark them as visited.

207. Course Schedule (find cycle in a graph)(interesting)
[medium-hard] boolean = canFinishDFS(node_int, map<node_int, adjacent_node_hashset_ofInt>, visitedNode_int_array)
// visited = 1, visiting= -1
private boolean canFinishDFS(HashMap<Integer, HashSet<Integer>> map,
                             int[] visited, int i) {
    if(visited[i] == -1) return false;
    if(visited[i] == 1) return true;  //pruning, means this node has confirmed without cycle.

    visited[i] = -1;
    if(map.containsKey(i)){
        for(int adjacent_node: map.get(i)){
            if(!canFinishDFS(map, visited, adjacent_node)) return false;
        }
    }
    visited[i] = 1;
    return true;
}

210. Course Schedule II(return one possible route)
[medium-hard] graph. similar to N207,  not sure why it's  "ret[index--]=i;" for backtracking. [TODO]

241. Different Ways to Add Parentheses(given a string of numbers and operators, return all possible results by group them differently. operators are ""+-*")(very interesting)
[medium-hard] List = DFS(string)   (divide and conquer)!!!    example: 2*3+5
if i is operator:  left_list = DFS(str.substring(0,i));  right_list = DFS(str.substring(i+1));
for n in left_list: for m in right_list: ret.add(compute(n,m,operator_at_i))
DFS and separate left and right by operator(+-*); for each of left and right, calculate their value.

306. Additive Number(return if a string is additive number,  199100199 is because [1, 99, 100, 199])
[medium-hard] boolean = DFS(num_string, left_int, right_int, first_num_int)
complicate on how to extract 3 numbers. [TODO]

310. Minimum Height Trees(given a tree-like graph, return a list of MHT root.)
[medium-hard] BFS, remove all leaf node until remain node <=2 and return.
map<node_int, list_of_adjacent_node>; node_int_array to store count of adjacent nodes; a list to store leaf node.

386. Lexicographical Numbers(Given an integer n, return [1,n] in lexicographical order, n=13; return [1,10,11,12,13,2,3,4,5,6,7,8,9])(interesting)
[medium] void = DFS(pre_num_int, n_int, ret)
public void dfs(int pre, int n, List ret){
    for(int i=0;i<=9;i++){
        int val = pre*10 + i;
        if(val > n) return;
        if(val > 0){
            ret.add(val);
            dfs(val, n, ret);
        }
    }
}

394. Decode String(interesting)
[medium] DFS.

401. Binary Watch
[easy-medium] DFS+backtracking or hashtable solution.

419. Battleships in a Board
[medium-easy] DFS+backtracking or a simple solution.





---------------------------------------------------
DP(reviewed on 10/2/2016)
---------------------------------------------------
62. Unique Paths(matrix, can only move down and right, return max unique path)(real question)
[easy] dp[i][j] = dp[i-1][j] + dp[i][j-1];

63. Unique Paths II(with obstacles marked as 1)(real question)
[easy-medium] rolling array.
if(obstacleGrid[i][j] == 1) dp[j] = 0;
else if(j>0) dp[j] += dp[j-1];  //(j>0) important

64. Minimum Path Sum(matrix, can only move down and right, return min path sum)
[easy]  dp[j] = min(dp[j-1], dp[j]) + grid[i][j].  similar to 62, but use rolling array(o(m) space).

70, climb stairs. (either 1 step or 2 steps, return distinct ways to the top)(real question)
[easy-medium]   dp[i] = dp[i-2] + dp[i-1].
this is kind of fibonacci, so can be: a=b=1; i in [2,n]{c= a+b, a=b, b=c;} return b;

91. Decode Ways('A'->1, ... 'Z'->26, return how many ways to decode a given string)
[medium] hard on how to analyze this problem. f(n) = f(n-1) + f(n-2) if valid in [1,26]
dp[0]=dp[1]=1;
if(isValid(s.substring(i-1, i))) dp[i] += dp[i-1];
if(isValid(s.substring(i-2, i))) dp[i] += dp[i-2];

120. Triangle(minimum path sum from top to bottom, move down only adjacent)[important]
[medium] (Bottom up DP!!!) rolling array. dp[i] = min(dp[i], dp[i+1]) + matrix[i][j]

121. Best Time to Buy and Sell Stock(at most one transaction)
[easy-medium] greedy. store global min, and update max each time.
minVal = min(minVal, a[i]);  ret = max(ret, a[i]-minVal);

122. Best Time to Buy and Sell Stock II(could buy and sell as much as possible.)
[easy-medium] greedy. add up all the positive difference between two days.

123. Best Time to Buy and Sell Stock III(at most 2 transaction)(interesting)
[hard-medium] two passes DP. divide and conquer.
find max profit <= i and max profit >= i. combine them ret = max(ret, left[i]+right[i])

188. Best Time to Buy and Sell Stock IV(allow at most k transaction)
[hard] two array DP. [TODO]

309. Best Time to Buy and Sell Stock with Cooldown
[medium-hard] not sure. [TODO]

139. Word Break(check if string can be segmented into a few words in a given dictionary)
[medium-hard] DFS will TLE.  similar to N132. Palindrome Partitioning II
dp[0]=true; for each substring, if (dp[j]==true && word.contains(s.substring[j,i+1)) dp[i+1] = true;

140. Word Break II(add spaces in str to construct a sentence, return all possible results.)
[hard]  DP + DFS + backtracking. need a ArrayList<String>[] preWordsList;
store each dictionary word in preWordsList, add to ret by backtracking with matching str length.

53	Maximum Subarray(max continuous subarray)(real question)
[easy] local_max = Math.max(local_max+num, num);  ret = Math.max(ret, local_max);

152. Maximum Product Subarray(return the largest product in a contiguous subarray)(interesting)(real question)
[medium] DP or greedy.  need cur_max and cur_min.
    int tmp = cur_max;
    cur_max = Math.max(nums[i], Math.max(cur_max*nums[i], cur_min*nums[i]));
    cur_min = Math.min(nums[i], Math.min(tmp*nums[i], cur_min*nums[i]));
    max = Math.max(max, cur_max);

198. House Robber(return maximum money can rob but not adjacent houses.)(real question)
[easy] dp[i] = max(dp[i-i], dp[i-2] + num[i]).
or greedy, use even and odd. even=max(even,odd); odd=max(even,odd);

213. House Robber II(house in a circle)(real question)
[medium] two passes of DP, 1. remove head.  2. remove tail.

337. House Robber III(binary tree, very interesting)
[medium-hard] DFS + DP(hashtable).  int = DFS(node, map), naive is not using map.
public int rob(TreeNode root, HashMap<TreeNode, Integer> map) {
    if (root == null) return 0;
    if(map.containsKey(root)) return map.get(root);

    int val = 0;
    if (root.left != null) val += rob(root.left.left, map) + rob(root.left.right, map);
    if (root.right != null) val += rob(root.right.left, map) + rob(root.right.right, map);
    val =Math.max(val + root.val, rob(root.left, map) + rob(root.right,map));
    map.put(root, val);
    return val;
}

204. Count Primes(return number of primes less than n)(interesting)
[easy-medium] dp[i*j] = false
set dp[0,n] =true; if dp[i] IS prime, set dp[i*j] = NOT Prime, while j in[2,i*j<=n]; then count.

279. Perfect Squares(find the least number of perfect square numbers sum to n. 4+9=13)
[medium] similar to N204.  dp[i+j*j] = Math.min(dp[i+j*j], dp[i]+1);
for(int i=0;i<=n;i++){
    for(int j=1;i+j*j<=n;j++){
        dp[i+j*j] = Math.min(dp[i+j*j], dp[i]+1);
    }
}

322. Coin Change(return fewest number of coins sum to a val)(real question)
[medium] similar to N279.  dp[i+j] = min(dp[i+j], dp[i]+1)
int[] dp = new int[amount+1];
for(int i=1;i<=amount;i++) dp[i] = Integer.MAX_VALUE;
for(int i=0;i<amount;i++){
    for(int coin: coins){
        if(i+coin <= amount && dp[i] != Integer.MAX_VALUE)
            dp[i+coin] = Math.min(dp[i+coin], dp[i]+1);
    }
}
return dp[amount] == Integer.MAX_VALUE? -1 : dp[amount];

221. Maximal Square(matrix with 0 and 1, find largest square with all 1 and return its area.)
[medium] if matrix[i][j] == '1':  dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])
(time o(m*n), space(m*n), space can be reduced use rolling array and one variable)


300. Longest Increasing Subsequence(return max length of increasing subsequence in array)(interesting)
[medium] dp[i] = Math.max(dp[i], dp[j]+1)
for(int i=0;i<nums.length;i++){
    dp[i] = 1;
    for(int j=0;j<i;j++){
        if(nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[j]+1);
    }
    max = Math.max(max, dp[i]);
}

303. Range Sum Query - Immutable(find the sum of the elements between indices [i,j])
[easy] sum(i) = sum[0,i); return sum(j+1)-sum(i);
sum = new int[nums.length + 1];
for (int i = 0; i < nums.length; i++) {
    sum[i + 1] = sum[i] + nums[i];
}

304. Range Sum Query 2D - Immutable
[easy-medium] similar N303, but in matrix, sum by row and add each row.

338. Counting Bits(return number of 1 bits in range[0,n])(very interesting)
[medium] DP + bit. ret[i] = ret[i>>1] + (i&1)  for i in [1,num]

368. Largest Divisible Subset(find largest set each si%sj==0)(interesting)
[medium-hard] DP+backtracking. [TODO]

375. Guess Number Higher or Lower II
[medium] 2d DP. [TODO]

376. Wiggle Subsequence(return length of longest wiggle subsequence)(interesting) [TODO]
[medium] alternate DP. if(num[i]>num[i-1])p=q+1; else if(num[i]<num[i-1])q=p+1; return max(p,q);

416. Partition Equal Subset Sum
[medium] find half sum of array and DP.


---------------------------------------------------
Divide and conquer
---------------------------------------------------
395. Longest Substring with At Least K Repeating Characters(interesting)
[medium]




---------------------------------------------------
Greedy
---------------------------------------------------
55. Jump Game(each num means the longest distance you can jump, can you reach the end?)
[easy] o(n). store max_jump and compare with end index.

45. Jump Game II(return min jumps to end, assume there is a solution)(interesting)
[hard-medium] greedy. store max_jump and cur_jump.
int ret=0, last_jump_max=0, cur_jump_max=0;
for(int i=0;i<nums.length-1;i++){
    cur_jump_max = Math.max(cur_jump_max, i+nums[i]);
    if(i == last_jump_max){
        ret++;
        last_jump_max =cur_jump_max;
    }
}
return ret;

134. Gas Station(N gas stations along a circular route, cost[], gas[], return start point can circle around)
[easy-medium] greedy. read problem description carefully, because guaranteed solution
to be unique if failed at i, we can give up all index [0,i], start checking from i+1.
reset current_sum to 0 if <0 and start=i+1; overall_sum should also >0;

455. Assign Cookies
[easy] sort, greedy. count++ when size of cookie >= child's greed.




---------------------------------------------------
Hash Table(reviewed on 9/29/2016, 10/28/2016)
hashmap can be used as count each char/num, or store index of char/num
hashset usually used to check if visited or not.
---------------------------------------------------
1. Two Sum(real question)(interesting)
[easy] store (sum-num[i]) and index in hashtable.  map(sum-num[i], index)
throw new IllegalArgumentException("No solution");

36. Valid Sudoku
[easy-medium] hashset to check if visited.

166. Fraction to Recurring Decimal
[medium-hard] use hashtable to store visited number, and add brackets before it.

187. Repeated DNA Sequences(find all repeated 10-length string)
[easy-medium] 2 hashsets. one is for seen, if seen, add to ret set.  or count each string, output count>=2;

202. Happy Number
[easy] put calculated number in hashset to detect duplicate.

205. Isomorphic Strings(Two strings are isomorphic if the characters in s can be replaced to get t.)case: aa and ab.
[easy-medium] two way hashtables. return func(s,t) && func(t,s);

290. Word Pattern
[easy-medium] two way hashtables, the same as N205.   map(char, String) and map(String, char)

217. Contains Duplicate(if duplicate integer exist in an array.)
[easy] hashset.

219. Contains Duplicate II(duplicate within k distance)
[easy] hashtable, value and idnex. check distance.  map(num, its index);

220. Contains Duplicate III
[medium-hard]  treeset? [TODO]

299. Bulls and Cows
[easy-medium] need a counter int[] for each number.
if(counter[secret_num]++ < 0) cow++; if(counter[guess_num]-- >0) cow++;
int num_bull=0, num_cow=0;
int[] nums = new int[10];
for(int i=0;i<secret.length();i++){
    if(secret.charAt(i) == guess.charAt(i)) num_bull++;
    else{
        if(nums[secret.charAt(i)-'0']++ < 0) num_cow++;
        if(nums[guess.charAt(i)-'0']--  > 0) num_cow++;
    }
}
return num_bull+"A"+num_cow+"B";

318. Maximum Product of Word Lengths(interesting)
[medium] 1. hashset to store chars for each word. time o(n^2), space(26*n)
2. optimize, store each char in an int[] as bit, do "&" for each int. time o(n^2), space(n)

347. Top K Frequent Elements(interesting)(real question)(google)
[medium] bucket sort o(n) time but o(n) space: map(count, num). List[] buckets= new List[num.length+1];
heap o(nlogn) time, but o(k) space.

451. Sort Characters By Frequency(google, amazon)
[medium] counting/bucket sort.  o(n).

349. Intersection of Two Arrays
[easy] find intersect of two hashset.

350. Intersection of Two Arrays II
[easy-medium] find intersect of two hashtables, value on count of each num.

383. Ransom Note(if "A" can be constructed from "B")(real question)
[easy] hashtable, count and compare each char.

387. First Unique Character in a String
[easy-medium] two pass. map(char, count).  return the first count==1 foreach char in str(not map).

388.Longest Absolute File Path
[medium] hashtable to store last level length(will be replaced by new line).
process line by line using s.split("\n"); "\t" is counted as one char.

389. Find the Difference(find one different char in two strings)
[easy] two pass. 1st: map(char, count)  2ed: count--; return if count<0;

409. Longest Palindrome(interesting)
[easy-medium] ret += (odd-1)

447. Number of Boomerangs
[easy-medium] hashmap to store previous distance, ret += pre_dist*2; map.put(dist, pre_dist+1);

454. 4Sum II
[medium] hashmap on(C[i] + D[j]), check if exist in map (-1*(A[i]+B[j])). time o(n^2)



---------------------------------------------------
Interval(reviewed on 10/27/2016)
---------------------------------------------------
56. Merge Intervals
[hard-medium] sort. Collections.sort(intervals, (Interval a, Interval b)-> a.start - b.start);
two pointers, start and end. if end < next.start; add to interval(start,end) to list; update start and end;
else if end < next.end; end = next.end;   // else when end > next.end do nothing

57. Insert Interval
[hard-medium] insert new interval to sorted list and use solution from N56 to merge.

252. Meeting Rooms(VIP)(detect if there is intersect of interval)
[easy] return false if interval[i].start < interval[i-1].end

253. Meeting Rooms II(VIP)(interesting)
[medium] using heap sorted by interval.end to merge adjacent intervals greedily.
return heap.size();

435. Non-overlapping Intervals
[medium] similar to N452. keep track of end, remove larger end.

452. Minimum Number of Arrows to Burst Balloons(interesting)
[medium] similar to N435. keep track of end point, compare it with next start point.

436. Find Right Interval(interesting)
[medium] BF is o(n^2).
treemap to sort key(interval.start), value=index. cellingEntry(key) to do binary search. o(nlogn)


---------------------------------------------------
Linked List(reviewed on 10/27/2016)(out of box thinking, modify value in node)
---------------------------------------------------
2. Add Two Numbers(real question)
[easy-medium] carry. one list is shorter than the other. extra carry node. similar to N415.

19. Remove Nth Node From End of List
[easy] two pointers, one moves N steps ahead.

21. Merge Two Sorted Lists(real question)
[easy] dummy node.

24. Swap Nodes in Pairs(swap adjacent node)(real question)
[easy-medium] dummy node and odd and even.  need three pointers to swap: pre, cur and nextNode.

206. Reverse Linked List
[easy-medium] iterative one. need pre, cur, next. similar to N24.

92. Reverse Linked List II(from position m to n)
[medium] dummy node to solve first node issue. need extra pre_m, m_node to link head and tail.
pre_m.next = pre, m_node.next=cur.  pre, cur, next for reversing node. m-- >1; n-- >1

61. Rotate List
[easy-medium] just need link tail and head, break one link, reset head node.
count node, tail -> head, move n - k steps, head = tail.next, tail.next = null

83. Remove Duplicates from Sorted List
[easy] skip next if equals. if ==, cur.next=cur.next.next, else cur = cur.next.

82. Remove Duplicates from Sorted List II(only return unique node, remove all nodes exists more than once)
[medium] need dummy node to skip the first one. check next.val == next.next.val
store duplicate value by checking cur.next.val == cur.next.next.val , and skip all duplicate if equals duplicate value.

86. Partition List(move node.val < x to list 1, move node.val >= x to list 2, and link them.)
[medium] two dummy nodes as the start of each list, two p pointers points to current node will end up to the tail of each list.

141. Linked List Cycle
[easy] two pointers, slow and fast. while(fast!=null && fast.next != null) ...

142. Linked List Cycle II(find entrance of cycle)
[medium] once they meet, reset slow to head, and move them at the same pace, they will meet at the entrance.

143. Reorder List (1->2->3->4   ----->    1->4->2->3)
[medium] find mid point, and reverse the second half, and merge them.

147. Insertion Sort List
[medium] need dummy node. for each node insert it to it's proper position.

148. Sort List(interesting)
[medium] merge sort.
if(head==null || head.next==null) return head;
slow = head, fast = head.next.next // important, make sure slow is the node before mid node.
ListNode l1 = sortList(slow.next);
slow.next=null;
ListNode l2 = sortList(head);
return merge(l1, l2);

160. Intersection of Two Linked Lists(interesting)
[easy-medium] subtract the length of two lists. the longer one moves the diff steps first.

203. Remove Linked List Elements
[easy] 1. dummy node to handle first node
2. or while loop to skip the first node.

234. Palindrome Linked List(require o(1) space)
[easy-medium] reverse the first half while find mid point; compare reversed with slow. [TODO not implemented yet]

237. Delete Node in a Linked List (only access to that node.)
[easy] copy node value. remove the next node.

328. Odd Even Linked List
[easy-medium] one pointer for odd, one pointer for even.
while(even!=null && even.next != null) {...}


---------------------------------------------------
Math(reviewed on 10/27/2016)
---------------------------------------------------
7. Reverse Integer(real question)
[easy-medium] ret = ret*10 + x%10; x/=10; overflow, negative, trailing zeros?

43. Multiply Strings
[medium] o(n^2), p1 = i+j; p2=i+j+1; sum = product + ret[p2]; ret[p1] += sum /10; ret[p2] = sum % 10;

60, Permutation Sequence.
[medium to hard] math, k / (n-1)! for current number,  k%(n-1)! for next iteration.

168. Excel Sheet Column Title(convert base 10 to base 26)
[easy-medium] construct from right to left, use mod first then divide. n-- to solve non-zero issue.

171. Excel Sheet Column Number(convert base 26 to base 10)
[easy] sum = sum *26 + (s.charAt(i)- 'A' + 1); for(i in [0,n-1])

172. Factorial Trailing Zeroes
[easy] count number of 5s, equal trailing zeros. time o(log5)
while(n>0){
    n = n/5;
    ret += n;
}

223. Rectangle Area
[easy-medium] overlap(sum of 2 separate - overlap area) vs non-overlap(sum of 2 separate area).

258. Add Digits
[easy] digital root. ret = n%9; if ret==0; return 9;

263. Ugly Number[code is N262](only has factor of 2,3,5)
[easy] while loop (n/=5, n/=3, n/=2) return n==1;

264. Ugly Number II(interesting)(return nth ugly number)
[medium] DP. maintain l1, l2, l3 in dp[], next k =  min(dp[l1]*2, dp[l2]*3, dp[l3]*5);

292. Nim Game(grab 1-3 stones, grab the last one win, you take the first grab.)
[easy] you lose only when remains 4*n;

319. Bulb Switcher
[medium] return (int)Math.sqrt(n);

231. Power of Two(use bit)
[easy] return n>0 && (n & n-1) == 0;

326. Power of Three
[easy] recursively divide 3.

342. Power of Four
[easy] recursively divide 4.

343. Integer Break
[easy-medium] choose from [0,2] of 2, the rest should be 3.

357. Count Numbers with Unique Digits
[medium] f(k) = 9 * 9 * 8 * ... (9 - k + 2) [TODO]

365. Water and Jug Problem
[medium] return z % gcd(x,y) == 0; gcd{while (b!=0){ a=b; b=a%b} return a; }

367. Valid Perfect Square(9=1+3+5 ...)(interesting)
[medium] tmp=1; while(num>0) num -= tmp; tmp+=2; return num==0;

390. Elimination Game
[medium-hard] move head only when 1. move from left, 2 move from right when remain is odd.
each time step *=2; remain /=2;

396. Rotate Function
[easy-medium] math.
Sum=f0+f1+...fn
F0 = 0*f0 + 1*f1 + n*fn
F1 = F0 + sum - n*f(n-1)
...

423. Reconstruct Original Digits from English
[medium] find pattern.

441. Arranging Coins
[easy-medium] math or binary search.

453. Minimum Moves to Equal Array Elements
[easy-medium] think from the opposite way, add n-1 == minus 1;  ret= sum_of_array - n*min;

462. Minimum Moves to Equal Array Elements II
[medium] math. sort and while(i<j) ret += nums[j--] - nums[i++];




---------------------------------------------------
Palindrome(DFS + backtracking or DP)(reviewed on 10/1/2016, 12/1/2016)
---------------------------------------------------
https://leetcode.com/articles/longest-palindromic-substring/#approach-5-manachers-algorithm-accepted    Manacher's Algorithm
5. Longest Palindromic Substring(read question)(important)
[medium-hard] 1. BF is o(n^3).  2. Manacher's Algorithm is o(n). non-trivial.
3. for each i, call isPal(i,i) and isPal(i,i+1) o(n^2)
4. getPal(s,i,i) and getPal(s,i,i+1);  use this solution.
    for(int i=0;i<s.length();i++){
        String cur = isPal(s, i, i);
        if(cur.length() > ret.length()) ret = cur;

        cur = isPal(s, i, i+1);
        if(cur.length() > ret.length()) ret = cur;
    }
    return ret;

public String isPal(String s, int left, int right){
    while(left>=0 && right<s.length()){
        if(s.charAt(left) == s.charAt(right)){
            left--; right++;
        }else break;
    }
    return s.substring(left+1, right);
}

9. Palindrome Number(real question)
[easy-medium] 1. convert to string.
2. create div the same digits as number, use it to get left digit

125. Valid Palindrome
[easy-medium] consider case and special chars. two pointers start from left and right end.

131. Palindrome Partitioning(find all possible palindrome partitioning of s)
[medium-hard] DP+DFS+backtracking.
DP(n^2) to store all substring isPal, DFS+backtracking on all substring. (~ o(n!))

132. Palindrome Partitioning II(Return the minimum cuts needed for a palindrome partitioning of s)
[hard] similar solution as 131 will TLE. add another DP condition in isPal[][] dp. o(n^2)
DP cut[j] = min(cut[j], cut[i-1] + 1) inside a[i] == a[j] condition.

214. Shortest Palindrome(add chars in front of string to make it palindrome)(tricky)
[hard] String, recursive. prefix, suffix and middle. [TODO]

234. Palindrome Linked List
[easy] o(n) space, convert to string.
[medium] o(1) space. reverse first half list. [TODO]


266. Palindrome Permutation(VIP)
267. Palindrome Permutation II(VIP)(real question)(Akamai)


336. Palindrome Pairs
[hard] hashtable + divide conquer.
split each words str1 and str2, and check if isPal(str2) and reversed(str2) in map. [TODO]



---------------------------------------------------
Random(reviewed on 10/27/2016, 12/1/2016)
---------------------------------------------------
382. Linked List Random Node
[medium] save list to array, and call random. o(n) space
follow up: o(1) space, o(n) time. see Reservoir Sampling. update ret when rand.nextInt(++count) == target(most likely 0)

384. Shuffle an Array
[medium] FisherYates shuffle.
https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle

398. Random Pick Index
[medium] Reservoir Sampling
    int ret = 0, count=0;
    for(int i=0;i<nums.length;i++){
        if(nums[i] == target){
            int j = rand.nextInt(++count);
            if(j==0) ret = i;
        }
    }
    return ret;

---------------------------------------------------
Sliding Window(reviewed on 10/27/2016, 11/14/2016, 12/1/2016)
all is compare count with k([0,n]) except N424, use window - maxRepeatingChar compare with k.
---------------------------------------------------
3. Longest Substring Without Repeating Characters(interesting)(real question) abcdf
[medium] BF is o(n^2). windows contains only unique chars. ret = Math.max(ret, i-left+1);
hashtable + sliding window with two pointers. o(n) time,  map(char, index)
map to store index of previous duplicate num[i], update left if found in map.
    for(int i=0; i<s.length();i++){
        if(map[a[i]]++ >= 1) count++;  // >=1   count here means count of repeating chars
        while(count > 0){ // move left pointer one by one
            map[a[left]]--;
            if(map[a[left]] >= 2) count--;  // >=2
            left++;
        }
        ret = Math.max(ret, i-left+1);
    }

159. Longest Substring Which Contains at most 2 Unique Characters(VIP)(interesting) aaabbb
340. Longest Substring Which Contains at most k Unique Characters(VIP)(interesting)(real question)(Facebook)
[hard-medium] windows contains only unique k chars. ret = Math.max(ret, i-left+1);
sliding window with k size. use help of hashmap<char, count> or int[256] to move window.
    for(int i=0; i<str.length; i++){
        if(map[str[i]]++ == 0) count++;  // ==0  count here means count of unique chars
        while(count>k){
            map[str[left]]--;
            if(map[str[left]]==0) count--; // ==0
            left++;
        }
        ret = Math.max(ret, i-left+1);  //windows only contains at most k unique chars.
    }

424. Longest Repeating Character Replacement(real question)(google)(tricky to move window)[to think more]
[medium-hard] store previous max length.
for(int i=0;i<a.length;i++){
    maxRepeatChar = Math.max(maxRepeatChar,  ++map[a[i]]); // add window
    while(i-left+1 - maxRepeatChar > k) { // move window when (window_length - count > k)
        map[a[left]]--;
        left++;
    }
    ret = Math.max(ret, i-left+1);  //update ret to window size
}

76. Minimum Window Substring(given two strings s and t, find minimum window in s contains t.)(interesting)
[hard-medium] sliding window.
    int[] map = new int[128];
    for(char c: t.toCharArray()) map[c]++;
    int left=0, right=0, count=t.length(), start=0, len= Integer.MAX_VALUE;
    char[] a = s.toCharArray();
    while(right< s.length()){
        if(map[a[right++]]-- >= 1) count--;  // >=1
        while(count == 0){ // downsizing window
            if(right-left < len){
                len = right - left;
                start = left;
            }
            if(map[a[left++]]++ >=0) count++; // >=0
        }
    }
    return (len == Integer.MAX_VALUE)? "": s.substring(start, start+len);

438. Find All Anagrams in a String(interesting)
[easy-medium] a window of size p. similar to N76.
    int[] map = new int[128];
    for(char c: p.toCharArray())map[c]++;

    int left=0, right=0, count=p.length();
    char[] a = s.toCharArray();
    while(right<s.length()){
        if(map[a[right++]]-- > 0) count--;
        if(count == 0) ret.add(left);
        if(right-left == p.length() && map[a[left++]]++>=0) count++;
    }
    return ret;


209. Minimum Size Subarray Sum(interesting)
[medium-easy] sliding window. not need of count, easy.
    int front=0, min = Integer.MAX_VALUE, sum=0;
    for(int i=0;i<nums.length;i++){
        sum += nums[i];
        if(sum>=s) {
            //advance front
            while(sum-nums[front] >=s){
                sum -= nums[front];
                front++;
            }
            min = Math.min(min, i-front+1); //update min
        }
    }
    return min == Integer.MAX_VALUE ? 0 : min;


---------------------------------------------------
Sort(reviewed on 10/10/2016, 12/1/2016)
---------------------------------------------------
179. Largest Number(given [3, 30, 34, 5, 9], the largest formed number is 9534330.)
[medium] custom sort base on String desc (330 before 303)
Collections.sort(list, (a, b)-> (""+b+a).compareTo(""+a+b));

215. Kth Largest Element in an Array
[medium] quickselect, time o(n) = n + n/2 + n/4 .., space o(1), compare quicksort with quickselect
heap, time o(nlogk), space o(k)

PriorityQueue<Integer> heap = new PriorityQueue<Integer>(k);
for(int e : nums){
    if(heap.size()<k) heap.add(e);
    else{
        if(e > heap.peek()) {
            heap.poll();
            heap.add(e);
        }
    }
}
return heap.poll();


406. Queue Reconstruction by Height(interesting)(tricky)
[medium] sort + insertion.sort descending by height and ascending of rank
Arrays.sort(people, (a,b) -> a[0] == b[0]? a[1]-b[1] : b[0]-a[0]);// sort height reversely, and rank
List<int[]> ret = new LinkedList();
for(int[] p : people){
    ret.add(p[1], p);//insert people to its position by rank
}
return ret.toArray(new int[people.length][]);

---------------------------------------------------
Stack/Queue(reviewed on 9/29/2016, 10/27/2016)
---------------------------------------------------
20. Valid Parentheses(real question)
[easy] push if it's opening parenthesis like "({[", else stack.pop, return false if not matched closing parenthesis.")}]"

71. Simplify Path
[medium] pop if it's "..", continue if it's '.', else push

150. Evaluate Reverse Polish Notation(real question)
[easy] if operand, pop twice and evaluate and push back, else push.

155. Min Stack(interesting)(real question)
[easy-medium] two stacks. stack, minStack.
push to minstack only when it's empty or incoming is <=(equal to handle duplicate) than minStack.top();
pop minStack only when val = top.
used the trick of stack's top always be the smallest until a smaller comes after.

225. Implement Stack using Queues(real question)
[easy-medium] two queues to mimic stack.

232. Implement Queue using Stacks(real question)
[easy-medium] two stacks to mimic queue.


224. Basic Calculator [TODO]
[hard]

227. Basic Calculator II [TODO]
[medium]

372. Super Pow
[medium-hard] stack and recursion. kind of math, a^25 = (a^2)^10 * a^5;

402. Remove K Digits(impressive idea) example: 12345, 54321, 100234, 500432
[medium-hard] stack, pop stack when stack.peek() > num; k--;

456. 132 Pattern
[medium] stack solution, require one < three < two.



---------------------------------------------------
String(reviewed on 9/29/2016, 12/1/2016)
---------------------------------------------------
5. Longest Palindromic Substring(interesting)(real question)[must]
[medium-hard] BF is o(n^3).
Manacher's Algorithm is o(n) (non-trivial, not expected at interview.)
o(n^2) for each i, call isPal(i,i) and isPal(i,i+1);  return s.substring(start+1, end)

6. ZigZag Conversion(interesting)
[easy-medium] need StringBuilders[], sb[index]=c; index ++ or -- to put c in different row of sb.
offset=1 reached first SB; offset=-1 when reached last SB. index+=offset
StringBuilder[] sb = new StringBuilder[numRows];
for(int i=0;i<numRows;i++) sb[i] = new StringBuilder();

int index=0, offset=1;
for(char c: s.toCharArray()){
    sb[index].append(c);
    if(index == 0) offset = 1;
    else if(index == numRows-1) offset = -1;
    index += offset;
}

StringBuilder ret = new StringBuilder();
for(int i=0;i<numRows;i++) ret.append(sb[i]);
return ret.toString();

8. String to Integer (atoi) (real question)
[easy-medium] str.chatAt(i)-'0'
detail coding. leading/trailing spaces, negative/positive sign, non-chars, overflow/underflow?

12. Integer to Roman(real question)
[medium]
String[] symbol={"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
int[]     value={1000,900,500,400, 100, 90,  50, 40,  10, 9,   5,  4,   1};
StringBuilder sb = new StringBuilder();
for(int i=0;num!=0; i++){ //important num!=0
    while(num >= value[i]){
        num -= value[i];
        sb.append(symbol[i]);
    }
}

13. Roman to Integer(hard on find the pattern)(real question)
[easy-medium] sum-=num[i] if num[i] < num[i+1]; else sum+=num[i]

14. Longest Common Prefix
[easy] vertical scan each char in all strings and compare.

38. Count and Say(real question)(facebook)
[easy-medium] count duplicate num and construct count+"i" set to next string.
String ret = "1"; //base case when n=1
int count=1;
for(int j=1;j<n;j++){
    StringBuilder sb = new StringBuilder();
    for(int i=0;i<ret.length();i++){
        if(i<ret.length()-1 && ret.charAt(i) == ret.charAt(i+1)){
            count++;
        }else{
            sb.append(count+ ""+ret.charAt(i));
            count=1;
        }
    }
    ret = sb.toString();
}


67. Add Binary(return sum of two binary number of String)
[easy-medium]  from right to left. sum+=str.chatAt(i)-'0'; sum+=str.chatAt(j)-'0'; carry=sum/2;

415. Add Strings(real question)(google, add two arrays)
[easy] similar to N2(add linked list) and N67.

165. Compare Version Numbers
[easy-medium] problem says 1.22 > 1.3 because 22 > 3. build num between '.';
int i=0,j=0;
char[] c1 = version1.toCharArray(), c2 = version2.toCharArray();
while(i<c1.length || j<c2.length){
    int num1=0, num2=0;
    while(i<c1.length && c1[i] != '.') num1 = num1*10 + c1[i++] -'0';
    while(j<c2.length && c2[j] != '.') num2 = num2*10 + c2[j++] -'0';
    if(num1 > num2) return 1;
    if(num1 < num2) return -1;
    i++;j++;
}
return 0;

161. One Edit Distance(decide if two string are one char diff)(real question, VIP)[must]
[medium] 3 valid cases.
1. s="abc" t="aXc"(modify, same length); 2. s="abc" t="abcX"(append);  3. s="abc" t="abXc"(insert)
public boolean isOneEditDistance(String s, String t){
    int m = s.length, n = t.length;
    if(m>n) return isOneEditDistance(t,s); //make sure s is shorted than t
    int i=0, diff = n-m;
    if(diff>1) return false;
    while(i<m && s.charAt(i) == t.charAt(i))i++;
    if(i==m) return diff == 1; //append case, return false if s==t
    if(diff == 0) i++; // for modify case
    while(i<m && s.charAt(i) == t.charAt(i+diff)) i++; //insert and modify case.
    return i==m;
}

459. Repeated Substring Pattern
[easy-medium] build divisible substring and compare with original.
int size = str.length();
for(int i=size/2;i>=1;i--) {
    if (size % i == 0) {
        String sub = str.substring(0, i);
        StringBuilder sb = new StringBuilder();
        for (int j = 0; j < size / i; j++) sb.append(sub);
        if (sb.toString().equals(str)) return true;
    }
}


---------------------------------------------------
Two pointers(or Three pointers)(reviewed on 10/1/2016, 12/1/2016)
---------------------------------------------------
11. Container With Most Water(interesting)
[medium-easy] two pointers on left and right.
while(left < right){
    int min = Math.min(height[right] , height[left]);
    max = Math.max(max,  min * (right-left));

    while(left<right && height[left]<= min) left++;
    while(left<right && height[right]<= min) right--;
}

167. Two Sum II - Input array is sorted
[easy] two pointers. l++ and r--;

15. 3Sum(real question)
[medium-easy] BF(n^3). sort+two pointer makes it o(n^2). skip duplicate.
Arrays.sort(nums);
for(int i=0; i<nums.length-2;i++){
    if(i>0 && nums[i] == nums[i-1]) continue; //skip duplicate of i

    int left = i+1, right = nums.length-1;
    while(left < right) {
        int sum = nums[i] + nums[left] + nums[right];
        if (sum == 0) {
            ret.add(Arrays.asList(nums[i], nums[left], nums[right]));
            left++; right--;

            // skip duplicate of left and right
            while(left<right && nums[left] == nums[left-1]) left++;
            while(left<right && nums[right] == nums[right+1]) right--;
        }
        else if (sum > 0) right--;
        else left++;
    }
}


16. 3Sum Closest
[medium-easy] similar to N15 3sum. store ret and min_diff.
for(int i=0; i< nums.length-2; i++){
    int start = i+1, end=nums.length-1;
    while(start < end){
        int sum = nums[i] + nums[start] + nums[end];
        if(sum == target) return target;
        else if(sum< target) start++;
        else end--;

        int cur_diff = Math.abs(sum-target);
        if( cur_diff < min_diff) {
            min_diff = cur_diff;
            ret = sum;
        }
    }
}


18. 4Sum(prepare for ksum, DFS+backtracking)
[medium] similar to N15 3sum. o(n^3)

26. Remove Duplicates from Sorted Array
[easy-medium] i points to last unique one.
int i=0;
for(int n: nums){
    if(n != nums[i]) nums[++i] = n;
}
return i+1;


80. Remove Duplicates from Sorted Array II(duplicate allows twice)
[easy-medium] similar to 26, compare with num[i-1] rather than num[i].
int i=1;
for(int j=2;j<nums.length;j++){
    if(nums[i-1] != nums[j]) nums[++i] = nums[j];
}
return i+1;


27. Remove Element(remove given val)(real question)
[easy-medium] similar to N26, but i points to last removable one.
int i=0;
for(int n: nums){
    if(n != val) nums[i++] = n;
}
return i;


283. Move Zeroes
[easy-medium] similar to N27. if (num[i] != 0) num[i++] = num[j], and fill zeros to the end.
int i=0;
for(int n: nums){
    if(n != 0) nums[i++] = n;
}
for(int j=i;j<nums.length;j++) nums[j] = 0;


28. Implement strStr()
[easy-medium] BF is faster than KMP in most small cases.
while(i<sizeA && j<sizeB) if(A[i]==B[j]){i++;j++;} else {i=i-j+1;j=0}; return i-j if j==sizeB.
int i=0, j=0;
char[] t = haystack.toCharArray();
char[] p = needle.toCharArray();
while(i<t.length && j<p.length){
    if(t[i] == p[j]){
        i++;
        j++;
    }else{
        i = i-j+1;
        j = 0;
    }
}
int ret = -1;
if(j==p.length) ret = i-j;
return ret;


58, Length of Last Word.
[very easy] String operation. scan from last. o(n)
for(int i=s.length()-1; i>=0;i--){
    if(s.charAt(i) != ' ') ret++;
    else if(ret != 0) break;  // trailing spaces.
}


75. Sort Colors(sort 3 categories)(real question)(interesting)(akamai)
[easy-medium] two passed, counting each category and overwrite. (counting sort) two passes can also solve 4 colors.
(one pass)three pointers. if 0, swap(i++,left++), if 2, swap(i,right--), else i++; while(i<=right)


151. Reverse Words in a String(real question)(interesting)
[easy-medium] 1. trim().split(" +") to String[]. and reverse it.
2. scan word right to left with one pointer to the end of word, another check if a[i-1] == ' ';
    if(s.charAt(i) == ' ') j = i;
    else if(i==0 || s.charAt(i-1) == ' '){  // i==0 corner case, s.charAt(i-1) very good!!!
        if(sb.length() != 0) sb.append(" ");  // sb.length !=0 corner case.
        sb.append(s.substring(i,j));
    }
follow up: if there is no leading/trailing spaces and each word is separated by one space, do it o(1) space.
reverse[0,n-1]; reverse each word.

344. Reverse String
[easy] two pointers from both end.

345. Reverse Vowels of a String
[easy] two pointers find vowels and swap.

163. MissingRanges(VIP)(real question)(interesting)(return missing interval)(tricky)
[medium] cur-pre >=2, extra two sentinels, pre=start-1; cur = (i==num.length)?end+1; num[i];
public List<String> findMissingRanges(int[] nums, int lower, int upper) {
    List<String> ret = new ArrayList();
    Long pre = (long)lower-1;
    for(int i=0;i<=nums.length;i++){
        long cur = (i == nums.length)?(long)upper+1 : nums[i];
        if(cur - pre >= 2) ret.add(addString((long)pre+1, (long)cur-1));
        pre = cur;
    }
    return ret;
}
public String addString(long from, long to){
    return (from == to)? ""+from : from + "->" + to;
}

392. Is Subsequence
[medium-easy] two pointers. return i == a.length;







-----------------------------------------[hard]---------------------------------------------
149. Max Points on a Line(Given n points on a 2D plane, find the maximum number of points that lie on the same straight line)
[hard-medium] [hashtable+corner cases]time o(n^2). for each point, calculate slope for each pair and store in map<slope_double, count_int>;
corner case of duplicate points(b.x==a.x && b.y==a.y) and vertical points (b.x==a.x)

146. LRU Cache(implement get and set function for least recently used cache)
[hard] [design] [hashtable + double linked list]
linkedlist to represent Least recently used:
1. current get/set element will be put at the head of linked list
2. remove tail element when need delete.
3. hashmap<Element, Node> to enable o(1) to get/set element and operate on the node according to 1 and 2.




65. Valid Number
[hard] skip white space, sign, digits, point, digits, e, reset hasNumber, skip sign, digits, space.
return hasNumber && i==n;

68. Text Justification
[hard] [String] [TODO reduce code length]

44. Wildcard Matching(string match but support '?' and '*')
[hard] [string] time o(n). compare with N28 strstr. [TODO]

10. Regular Expression Matching('.' match single char, while '*' should match zero or more preceding chars.)
[hard] [DFS or DP] (tricky to write, hard to prove correctness.) [TODO]

4. Median of Two Sorted Arrays
[hard] [binary search] [tricky]  [TODO]

273. Integer to English Words
[hard] [String] [long code] [TODO reduce code length]

212. Word Search II
[hard] [TODO may need to move close to word search]

30. Substring with Concatenation of All Words(seem to be interesting)
[hard] [2 hashtable] [TODO]

174. Dungeon Game(return min number needed to reach from top left to bottom right. Matrix contains both positive and negative number, need at least 1 in each cell)
[hard-medium] Bottom-up DP.

32. Longest Valid Parentheses(given a string contains only '(' and ')', return length of longest well-formed parentheses substring)(interesting)
[hard] [stack to store index! ] [TODO]

295. Find Median from Data Stream
[hard-medium] [2 heaps]
Queue minHeap = new PriorityQueue<Integer>((o1,o2)-> o1-o2); maxHeap= ...(o2-o1);
minHeap.add(num); maxHeap.add(min.poll()); if (maxHeap.size > minHeap.size) minHeap.add(maxHeap.poll);

135. Candy(higher rating kids should get more candy than its neighbors in an array, each has at least one)(interesting)
[hard-medium] two pass DP. init set all dp[i]=1;
1 pass left to right: dp[i] = dp[i-1]+1 if(rating[i]> rating[i-1])
2 pass right to left: similar to first pass.

97. Interleaving String
[hard] matrix DP. [TODO]

41. First Missing Positive(require o(n) time and o(1) space)
[hard] kind of inplace swap to its position. [TODO]

84. Largest Rectangle in Histogram(return max area of an array represented histogram)(interesting.)
[hard] stack to store index, maintain the top of stack is the max value.
BF o(n^2), for each i, get area from left and right, left-- or right++ until a[i] > a[left] or a[right].
o(n) time. while(incoming < stack.top)pop and update max; else push and i++; while stack is not empty, update max.

85. Maximal Rectangle(problem similar to N221 Maximal Square, but can't use DP)
[hard] convert matrix to n rows of histogram, and use N84 solution to find max in each row.

23. Merge k Sorted Lists(real question)
[hard-medium] o(nlogk)
1. o(k) space, Heap to store k node. heap = new PriorityQueue<ListNode>((o1,o2)->o1.val - o2.val);
2. o(1) space, divide and conquer, merge 2 lists recursively.

138. Copy List with Random Pointer(return deep copy)(real question)(interesting)
[hard-medium]
1. o(n) space, map<node, new_node>; 1st pass to copy next node, 2ed pass to copy random node using map.
2. o(1) space, copy each node and added to its next, as A->A'->B->B'; node.next.random = node.random.next;

233. Number of Digit One
[hard] [math] [TODO]

37. Sudoku Solver(solve a sodoku in matrix, assume there is only one solution)
[hard-medium] DFS+backtracking.  void = DFS(matrix, seq_int)
for each cell if empty, DFS(matrix, seq_int+1);

282. Expression Add Operators(return all possible expression with added operators(+-*) equals target)
[hard] DFS+backtracking+Divide Conquer+Math.  void = DFS(ret, cur_str, num_string, target_int, start_int, sum_int, last_sum_int)
public void dfs(List<String> ret, String num, int target, String path, int pos, long sum, long lastNum){
    if(pos == num.length()){
        if(sum == target) ret.add(path);
        return;
    }
    for(int i=pos; i<num.length();i++){
        if(num.charAt(pos) == '0' && pos != i) break; // skip corner case like 000
        long cur = Long.parseLong(num.substring(pos,i+1));
        if(pos == 0) dfs(ret, num, target, path + cur, i+1, cur, cur);//first num, has to be i+1
        else{
            dfs(ret, num, target, path + "+" + cur, i+1, sum+cur, cur);
            dfs(ret, num, target, path + "-" + cur, i+1, sum-cur, -cur);
            dfs(ret, num, target, path + "*" + cur, i+1, sum-lastNum + lastNum*cur, lastNum*cur);
        }
    }
}

316. Remove Duplicate Letters(return unique lexicographical order)
[hard] count each char and stack.  [TODO]

87. Scramble String(test if two string are scramble of each other)
[hard] Divide and conquer + DFS.  boolean = DFS(str1, str2)  [TODO explore DP solution]
s1_1=s1.substring(0,i);  s1_2=s1.substring(i,n);
s2_1=21.substring(0,i);  s2_2=s2.substring(i,n);
if (dfs(s1_1, s2_1) && dfs(s1_2,s2_2)) return true;
s2 from right side, s3_1 = s2.substring(n-i,n) s3_2 = s2.substring(0,n-i);
if (dfs(s1_1, s3_1) && dfs(s1_2,s3_2)) return true;

51. N-Queens(return all possible matrix solution)
[hard] similar to N52, just need to build matrix.

52. N-Queens II(return number of possible solution)
[hard-medium] void =  DFS(n_int, row_int, visited_cols_list)
// if i and j in diagonal, ab(i_row - j_row) == ab(i_col - j_col)
public boolean isValidPosition(int row_index, int col_index, List<Integer> visited_cols){
    for(int i=0;i<visited_cols.size();i++){
        if(col_index == visited_cols.get(i) || Math.abs(row_index - i) == Math.abs(col_index - visited_cols.get(i)))
            return false;
    }
    return true;
}

164. Maximum Gap(return max difference between two neighbors in sorted form)(interesting)
[hard] BF. o(nlogn) sorted array, and gap = max(gap, a[i]-a[i-1]);
require o(n) time, bucket sort, at most (max-min)/len + 1 buckets. (TODO)

99. Recover Binary Search Tree(Two elements of a binary search tree (BST) are swapped by mistake, recover it.)
[hard] BF is o(n) space. save node to list, and sort values and reassign to each node.
o(1) space. morris traversal.  (TODO)

25. Reverse Nodes in k-Group(reverse k linked list node at a time)
[hard-medium] reverse part of linked list.

72. Edit Distance(return min steps to convert str1 to str2, 3 allowed operations: add, delete, replace)
[hard] matrix DP.  dp[0][i] = 1 and dp[i][0]=1; if c1 = c2; dp[i+1][j+1] = dp[i][j];
else  dp[i+1][j+1] = min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1;

239. Sliding Window Maximum(return an array of the max value in each k windows)(very interesting)
[hard] BF. time o(k*(n-k)), space o(1).  Find max in each K windows for (n-k) times.
o(n) time, but space o(k).  Deque<Integer> deque = new ArrayDeque<>();
use keep a descending deque of [1,k] elements, get max from the first. similar to min stack problem.
for(int i=0; i<nums.length;i++){
    // remove the first if out of range k
    if(!deque.isEmpty() && deque.peek() < i+1-k){
        deque.removeFirst();
    }
    // pop last if less than coming in
    while(!deque.isEmpty() && nums[deque.peekLast()] < nums[i]){
        deque.removeLast();
    }
    deque.addLast(i);
    if(i >= k-1){
        ret[ret_index++] = nums[deque.peek()];
    }
}

115. Distinct Subsequences(not sure the problem. [TODO])
[hard] 2D DP. dp[i][j] = dp[i-1][j];  if(s.charAt(i-1) == t.charAt(j-1)) dp[i][j] += dp[i-1][j-1];

297. Serialize and Deserialize Binary Tree(very interesting)
[hard-medium] Serialize: recursively preorder traversal node to store each node in String separated by ',';
Deserialize: split string by ',' to a list, recursively build tree back.
public TreeNode deserialize(LinkedList<String> list){
    String cur = list.removeFirst();
    if(cur.equals("null")) return null;

    TreeNode node = new TreeNode(Integer.valueOf(cur));
    node.left = deserialize(list);
    node.right = deserialize(list);
    return node;
}

354. Russian Doll Envelopes(return max doll you can fit in, need a.length > b.length && a.width>b.width)
[hard] DP time o(n^2), sort, similar to longest increasing sequence.  dp[j] = max(dp[j], dp[i] + 1);
public int maxEnvelopes(int[][] envelopes) {
    if(envelopes.length == 0) return 0;
    Arrays.sort(envelopes, (int[] a,int[] b)->(a[0] == b[0]?a[1]-b[1]:a[0]-b[0]));
    int[] dp = new int[envelopes.length];
    Arrays.fill(dp,1);
    int max = 1;
    for(int j=1;j<envelopes.length;j++){
        for(int i=0;i<j;i++){
            if(envelopes[j][0]>envelopes[i][0] && envelopes[j][1] > envelopes[i][1]){
                dp[j] = Math.max(dp[j], dp[i] + 1);
            }
        }
        max = Math.max(dp[j], max);
    }
    return max;
}
[TODO] Binary search o(nlogn)?

301. Remove Invalid Parentheses(return all valid results after remove invalid ones)
[hard] DFS or BFS. (TODO)

128. Longest Consecutive Sequence(return max length of consecutive sequence in array. like 1,2,3,4 ...)(interesting and impressive)
[hard-medium] require o(n) time. hashset.
put all num in hashset; go through each item in hashset and iterate through it's left and right, update max and remove them to prune.

42. Trapping Rain Water(return how much water can be trapped in the whole array)(interesting)
[hard-medium] 2 passes DP.
leftMostHeight[i] = Math.max(leftMostHeight[i-1], height[i-1]);
rightMostHeight[i] = Math.max(rightMostHeight[i+1], height[i+1]);
ret += max(Math.min(leftMostHeight[i], rightMostHeight[i]) - height[i] , 0)

287. Find the Duplicate Number(find the duplicate one in array with size n+1, but numbers are range [1,n])
[hard] require o(1) space, can't modify array, running time faster than o(n^2)
BF, time o(n^2) compare each number.
tricky solution, map of map. (TODO)

