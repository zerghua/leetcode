---------------------------------------------------
Anagram(words group like: cat, act) (reviewed on 9/28/2016)
---------------------------------------------------
49	Group Anagrams(important)
[medium] sorted string in hashtable, hm<String, List<>>, or Arrays.hashCode(int[] of each char in str) as int in hashmap key.

242	Valid Anagram(is valid anagram of two strings.)
[easy] hashtable or sort string.




---------------------------------------------------
Array (reviewed on 9/29/2016)
// for array problem, if sort is not efficient enough, use hash table or two pointers/sliding window
// if sorted or adjacent/continuous graph , it's usually binary search.
---------------------------------------------------
31. Next Permutation(hard on find the pattern)
[medium-hard] [TODO]

48. Rotate Image(rotate 90 degree of matrix)
[medium] extra space easy, ret[j][n-1-i] = matrix[i][j];  inplace, 4-way rotation. or transpose and flip(TODO).

53	Maximum Subarray(max continuous subarray)
[easy] condition on if local_max >0. sum+=n; ret = max(ret, sum); sum=max(0,sum)

54	Spiral Matrix(return array of spiral order, outer-->inner clockwise)
[medium] 4 loops of top,right,bottom and left side.

59, Spiral Matrix II(generate spiral n^2 matrix)
[medium] 4 loops of top,right,bottom and left side.

55. Jump Game(each num means the longest distance you can jump, can you reach the end?)
[easy]  o(n). store max_jump and compare with end index.

66. Plus One(to an array of digits)
[easy-medium]  find pattern. test case, 199, 999, 288, create new array only when like 999
for(int i=digits.length-1;i>=0;i--){
    if(digits[i] != 9 ){
        digits[i]++;
        return digits;
    }
    digits[i]=0;
}
// create new array if comes to here. like 999+1, return 1000
int[] ret = new int[digits.length+1];
ret[0]=1;
return ret;


73. Set Matrix Zeroes(require o(1) space.)
[medium] 1. record if the first row/col should should set to 0, 2. then use them to store this row/col should be set to 0,
3. set every cell, 4. set first row/col according to step 1.

88. Merge Sorted Array
[easy] fill from the end of array.

118. Pascal's Triangle(generate it. [1],[1,1],[1,2,1],[1,3,3,1]...)
[easy] find pattern. similar to tree level order traversal. use previous list to construct current list.

119. Pascal's Triangle II(find kth row, but only o(k) space)
[easy-medium] rolling array, scan from backward.
Integer[] row = new Integer[rowIndex+1];
Arrays.fill(row, 1);
for(int i=1; i<=rowIndex;i++){
    for(int j= i-1;j >= 1;j--){  // only works if backward
        row[j] += row[j-1];
    }
}
return Arrays.asList(row);


134. Gas Station(N gas stations along a circular route, cost[], gas[], return start point can circle around)
[easy-medium] greedy. read problem description carefully, because guaranteed solution
to be unique if failed at i, we can give up all index [0,i], start checking from i+1.
reset current_sum to 0 if <0 and start=i+1; overall_sum should also >0;

169. Majority Element(majority > n/2)
[easy-medium] counting number, count++ if the same; else count--; if count==0, ret=num[i], count=1
because majority > n/2, so it will always win with such counting.
int majorElement=nums[0];
int count=1;
for(int i=1;i<nums.length;i++){
    if(majorElement == nums[i]) count++;
    else count -- ;

    if(count == 0) {
        majorElement = nums[i];
        count=1;
    }
}
return majorElement;

229. Majority Element II(find out numbers exists times > n/3) Boyer_Moore_majority_vote_algorithm
[medium-hard] 2 variables to hold number, 2 counters.

189. Rotate Array
[easy] reverse 3 times. reverse(0,n-k-1); reverse(n-k,n-1); reverse(0,n-1)

238. Product of Array Except Self(can't use divide, require o(n) time) (tricky, kind of DP.)
[medium] two pass from left and right. product of all its left and right.
1st pass: ret[i] = num[i+1]*ret[i+1]; 2ed pass: ret[i] *= left_sum; left_sum *= nums[i];

274. H-Index[TODO]
[medium] sort o(nlogn), return i if reversed sorted a[i]<=i;
hashtable o(n) time, count each a[i], store in stat[], from [n,0) sum+=stat[i]; return i if sum>=i;

275. H-Index II(arrays is sorted, require logn)
[medium] binary search.
while(left<=right){
    int mid = (right-left)/2 + left;
    if(citations[mid] ==  n - mid) return n-mid;
    else if(citations[mid] < n -mid) left = mid+1;
    else right = mid-1;
}
return n-left;

289. Game of Life(require in-place, smart!!!)
[medium] use second bit in int to store next state. 0 --> 00 or 10,  1--> 01 or 11.

324. Wiggle Sort II[TODO]
[medium] sort and rearrange. [NOT easy to understand.]

334. Increasing Triplet Subsequence(3 increasing variables exists or not)
[easy-medium] a,b variables; each n compare with them and update. return true if larger than both

373. Find K Pairs with Smallest Sums[TODO]
[medium] heap time o(n*n).  can be optimized.

378. Kth Smallest Element in a Sorted Matrix
[medium] heap. put the first row in heap, poll from heap, push back with row++;


---------------------------------------------------
Binary search(reviewed on 9/28/2016 )
---------------------------------------------------
33. Search in Rotated Sorted Array
[hard-medium] 4 if conditions, compare num[mid] with num[left],
further compare target to num[left] and num[mid].

81. Search in Rotated Sorted Array II (duplicate in array)
[hard-medium] similar to 33, left++ if num[left] = num[mid]. worst case o(n)

34. Search for a Range(good)
[medium] more code when ==; update ret[0] and ret[1]; two direction recursion dfs(start, mid-1); dfs(mid+1,end)

35. Search Insert Position
[medium-easy] regular binary search, insertion position is the left bound; return left;

50. Pow(x, n) (real question)
[medium] binary search. while(n>0){if((n & 1) == 1)ret *=x; n>=1; x*=x; }

69. Sqrt(x)
[easy-medium] return left bound. negative number has not sqrt, use Long to handle overflow.

74. Search a 2D Matrix(can be converted to 1D row by row.)
[easy-medium] l=0, r=row*col-1; midVal = matrix[mid/col][mid%col],  time o(log(m+n))

240. Search a 2D Matrix II(sorted by rows and cols)
[easy-medium] o(m+n). start on top right point, row=0, col=col_size-1; row++ or col--;
time can also be o(mlogn) or o(nlogm)

153. Find Minimum in Rotated Sorted Array
[easy-medium]  if(num[mid]< num[r]) r= mid(not mid-1, because it can be the min);
else l = mid+1; return num[l]  while(l<r)

154. Find Minimum in Rotated Sorted Array II(duplicate is allowed)
[medium] if(num[mid] == num[r]) r--;  else are the same as 153.

162. Find Peak Element ((i==0 || num[i] > num[i-1]) && ( i= num.length-1 || num[i] > num[i+1]))(tricky)
[medium] if(i>0 && num[mid] < num[mid-1]) (search left) r=mid-1  , else (search right) l = mid+1

278. First Bad Version
[easy] if (mid is isBad){ret = mid; r =mid-1}; else l=mid+1;

374. Guess Number Higher or Lower
[easy] regular binary search.



---------------------------------------------------
Binary Tree
---------------------------------------------------
94. Binary Tree Inorder Traversal
[easy-medium] left-root-right. iterative, use stack. push p to stack if p is not null then p=p.left,  else if p==null, store stack.pop().val, and then p = p.right. while(p!=null || !s.isEmpty)

144. Binary Tree Preorder Traversal
[medium] iteratively. [TODO]

145. Binary Tree Postorder Traversal
[hard] iteratively.  [TODO]

100. Same Tree
[easy] DFS. return true if p == null && q==null, false if p==null || q==null, if p.val == q.val return dfs(p.left, q.left) && dfs(p.right, q.right) else return false

101. Symmetric Tree
[easy-medium] DFS or BFS. DFS compare left.val == right.val && dfs(left.left, right.right) && dfs(left.right, right.left).   BFS, two queues, lq.push(left,right), rq.push(right,left).

102. Binary Tree Level Order Traversal
[easy] BFS use queue, store size of each level. DFS pass level as argument.

107. Binary Tree Level Order Traversal II (return bottom up result)
[easy] almost the same as 102, just change ret.add(list) to ret.add(0,list);

103. Binary Tree Zigzag Level Order Traversal
[medium] 1. could reverse odd number of list with 102 solution. Collections.reverse(res.get(i));   2. use two stacks.

104. Maximum Depth of Binary Tree
[easy] DFS.  1 + max(dfs(node.left), dfs(node.right)). if(node ==null) return 0;

105. Construct Binary Tree from Preorder and Inorder Traversal
[medium] DFS. dfs(int[] preoder, int preorder_start, int preorder_end, int[] inorder, int inorder_start, inorder_end) if(preorder_start>preorder_end) return null, if (preorder_start==preorder_end) return new TreeNode(preorder[preorder_start]); else build it and recursive on left and right.

106. Construct Binary Tree from Inorder and Postorder Traversal
[medium] DFS. similar to 105.

110. Balanced Binary Tree
[easy-medium] DFS, if node ==null, return 0.  left_height = dfs(node.left), if(left_height==-1) return -1 ...  return 1+ max(left_height, right_height).

111. Minimum Depth of Binary Tree
[easy-medium] DFS. if(node.left==null || node.right==null) return 1 + max(dfs(node.left), dfs(node.right)),  else return 1 + min(dfs(node.left), dfs(node.right))

112. Path Sum
[easy-medium] DFS. if(root == null) return false;  if(root.val == sum && root.left ==null && root.right == null) return true; return dfs(root.left, sum-root.val) || dfs(root.right, sum-root.val)

113. Path Sum II
[medium] DFS + backtracking. pass along ret and cur_list. return condition is the same as 112. cur_list.add(root.val); dfs(ret, root.left, cur_list, sum-root.val); cur_list.remove(root.val)
 ... the same goes for right node.

114. Flatten Binary Tree to Linked List
[medium-hard] Morris Algorithm?  [TODO]

116. Populating Next Right Pointers in Each Node
117. Populating Next Right Pointers in Each Node II
[medium] share the same BFS level order traversal solution. with extra line of: if(i<size-1) node.next = q.peek(); for this linking next node.

129. Sum Root to Leaf Numbers(sum of each path from root to leaf)
[medium] DFS. tail recursion.
if(node==null) return 0; ret = sum*10+node.val;
if(left==right==null) return ret; return dfs(node.left, ret) + dfs(node.right, ret)

199. Binary Tree Right Side View
[easy] BFS, level order traversal from right to left.

222. Count Complete Tree Nodes (nlogn time)
[medium] binary search. left_height, right_height, if equal return (1<<left_height)-1; else recur(root.left) + recur(root.right) +1;

226. Invert Binary Tree
[easy-medium] tmp = invert(root.left); root.left = invert(root.right); roo.right= tmp;

236. Lowest Common Ancestor of a Binary Tree
[medium] top-bottom. if left and right children contains each of q and p, then return current node; else if one of them is returned, then that one is the result.

257. Binary Tree Paths
[easy-medium] DFS, pass ret to recursion.

307. Range Sum Query - Mutable
[medium-hard] segment tree. [TODO]

331. Verify Preorder Serialization of a Binary Tree
[medium] diff = outdegree - indegree = 1. each node count--; if not leaf, count+=2;



---------------------------------------------------
Binary Search Tree
---------------------------------------------------
96. Unique Binary Search Trees
[medium-hard] DP. catalan number. f(n) = f(0)*f(n-1) + f(1)*f(n-2) + ... + f(n-1)f(0)

95. Unique Binary Search Trees II
[medium-hard] DFS. foreach(start,n), left = (start,i-1), right=(i+1,n).

98. Validate Binary Search Tree
[easy-medium] DFS. pass along min, max value to validate. return false if root.val>=max || root.val <= min. then return dfs(root.left,min, root.val) && dfs(root.right,root.val, max).

108. Convert Sorted Array to Binary Search Tree
[easy] DFS. dfs(int[] a, int start, int end), if(start>end) return null. else build tree. mid = (left+right)/2  ...

109. Convert Sorted List to Binary Search Tree
[medium] 1. convert list to array.  2. two pointers find mid point each loop. 3. global pointer, very tricky, see 109 solution.

230. Kth Smallest Element in a BST  [favorite]
[medium] recursively count current node. if k == count return; else if count > k, dfs(root.left,k); else dfs(root.right, k-count);  or iteratively in-order traversal.

235. Lowest Common Ancestor of a Binary Search Tree
[easy] return if p < node.val < q. else recur left or right.




---------------------------------------------------
Bit Manipulation
---------------------------------------------------
29. Divide Two Integers
[medium] not sure. [TODO]

89. Gray Code
[medium] f(n) += reverse(f(n-1)) + 2^(n-1), use list to represent f(n)

136. Single Number(one number appears once while others twice)
[easy] xor on all the elements.

137. Single Number II(one number appears once while others three times)
[medium] on every bit, the sum of each bit is 3*n + (0 or 1). and all numbers bit by bit and mod 3 is the result.

190. Reverse Bits(unsigned integer)
[easy] ret = ret<< 1 || (n & 1); n >>= 1

191. Number of 1 Bits
[easy] ret += (n & 1);  n >>= 1

201. Bitwise AND of Numbers Range
[easy-medium] find common bits between n and m. (still not sure why only n and m)

268. Missing Number
[easy-medium] xor.  a^b^b = a

318. Maximum Product of Word Lengths
[medium] hashtable or store each char in an int[] as bit, do "&" for each int.

371. Sum of Two Integers
[easy-medium] [TODO]  not sure why.


---------------------------------------------------
Design
---------------------------------------------------
173. Binary Search Tree Iterator(next() return smallest in BST)
[medium] push all left node to stack until the left most.
when pop, if node.right!=null, push all its left. the reason it's o(1) time,
because each element is visited only once.

284. Peeking Iterator(existing functions are iterator.next and iterator.hasNext; add a peek function)
[medium] the key is to cache(save) next element with element and isPeeked variables.

341. Flatten Nested List Iterator
[medium] if number then add to list, else dfs(i.getList);

355. Design Twitter
[medium-hard] [TODO]






---------------------------------------------------
DFS/backtracking or BFS(better for shortest path)
---------------------------------------------------
17. Letter Combinations of a Phone Number
[medium] hashmap to map number and chars. DFS on each char.

22. Generate Parentheses(interesting)
[medium] return if left< right || ...; dfs(cur+"(", left-1, right; dfs(cur+")", left, right-1);


46  Permutations
47  Permutations II (contains duplicates)

78  Subsets(distinct numbers)
[medium] add all cur_list to ret in loop, cur_list as backtrack.

90  Subsets II (contains duplicates)
[medium] add all cur_list to ret in loop, sort and skip duplicate when i>start && num[i-1]=num[i]


39  Combination Sum
40  Combination Sum II (can't reuse same element)
216 Combination Sum III
377 Combination Sum IV



77  Combinations
[medium] return when size==k. return part of the subsets problem. cur_list as backtrack.

79. Word Search (Is a word in matrix)
[medium] 4 recursive calls inside one function. need visited[][] as backtrack, conditional and boundary check.

93. Restore IP Addresses
[medium] extra in level parameter to record which level we are in, use it for termination. pruning code for IP address like 00, 01, early break.

127. Word Ladder
[medium-hard]  BFS. add all neighbor words to list, and check level by level.

126. Word Ladder II(find all the path) (worth revisit)
[hard]  BFS + backtracking. long code.

130. Surrounded Regions
[medium-hard] start from 4 sides and mark all neighbors(BFS) from 'O' to 'P',
then set all 'O' to 'X', all 'P' to 'O'.  long code.

133. Clone Graph
[medium-hard] copy itself and copy its neighbors, use hashmap to store {new_node_label, new_node},
and return new_node if encountered to avoid duplicate. recursively add its neighbors.

200. Number of Islands
[medium] DFS, for each cell, do DFS on adjacent cells, and mark them as visited.

207. Course Schedule (find cycle in a graph)
[medium-hard] find cycle in graph. [TODO]

210. Course Schedule II
[medium-hard] graph. [TODO]

241. Different Ways to Add Parentheses(very interesting one.)
[medium-hard] DFS+backtracking+divide and conquer. DFS and separate left and right by operator(+-*); for each of left and right, calculate their value.

306. Additive Number
[medium-hard] complicate on how to extract 3 numbers. [TODO]

310. Minimum Height Trees(graph)
[medium-hard] BFS. remove leaf node until <=2

386. Lexicographical Numbers(interesting)
[medium] DFS. i in [0,9]{val=pre*10+i; if 0<val<n: ret.add() and dfs(val,ret) }



---------------------------------------------------
DP
---------------------------------------------------
62. Unique Paths
[easy] dp[i][j] = dp[i-1][j] + dp[i][j-1]

63. Unique Paths II
[easy-medium]  rolling array.  dp[j] += d[j-1]  when j>0

64. Minimum Path Sum
[easy]  dp[j] = min(dp[j-1], dp[j]) + grid[i][j].  similar to 62, but use rolling array(o(m) space).

70, climb stairs. (either 1 step or 2 steps)
[easy-medium]   dp[i] = dp[i-2] + dp[i-1].  or c= a+b, a=b, b=c

91. Decode Ways
[medium] dp[i] = dp[i-1] + dp[i-2] if substring(i-1,i) and substring(i-2,i) is valid dp[0]=dp[1]=1

120. Triangle
[medium] bottom up DP, rolling array. dp[i] = min(dp[i], dp[i+1]) + matrix[i][j]

121. Best Time to Buy and Sell Stock
[easy-medium] greedy. minVal = min(minVal, a[i]);  ret = max(ret, a[i]-minVal);

122. Best Time to Buy and Sell Stock II(could buy and sell as much as possible.)
[easy-medium] greedy. add up all the positive difference between two days.

123. Best Time to Buy and Sell Stock III
[medium-hard] two-way DP. find max profit <= i, find max profit >= i. and combine them. ret = max(ret, left[i]+right[i])

309. Best Time to Buy and Sell Stock with Cooldown
[medium-hard] not sure. [TODO]

139. Word Break(check if string can be segmented into a few words in a given dictionary)
[medium-hard] DFS will TLE.  use DP. DP, dp[i+1] = true if dp[j]==true && dict.contains(substring[j,i+1)) for j in [0,i]

140. Word Break II
[hard]  DP + DFS + backtracking. [TODO]

152. Maximum Product Subarray
[medium] DP or greedy. maxVal = max(maxVal, max(num*minVal, num*maxVal));  minVal = min(minVal, min(num*minVal, num*maxVal)); ret= max(ret, maxVal)

198. House Robber
[easy] dp[i] = max(dp[i-i], dp[i-2] + num[i]). or greedy, use even and odd.

213. House Robber II(house in a circle)
[medium] two times of DP, 1. remove head.  2. remove tail.

337. House Robber III(binary tree, interesting)
[medium-hard] DFS + DP(hashtable).

204. Count Primes
[easy-medium] if dp[i] is prime, set dp[i*j] = Not Prime, while j in[2,i*j<=n]; then count.

221. Maximal Square (time o(m*n), space(m*n), space can be reduced use rolling array and one variable)
[medium] if matrix[i][j] == '1':  dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])

279. Perfect Squares
[medium] for(j=1;i+ j*j<=n;j++) dp[i+j*j] = min(dp[i+j*j], dp[i]+1);

300. Longest Increasing Subsequence
[medium] dp[i]=1; if(nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[j]+1), for j in [0,i);

303. Range Sum Query - Immutable
[easy] extra length provides cleaner code. sum[i+1] = sum[i] + nums[i]; return sum[j+1]-sum[i]

304. Range Sum Query 2D - Immutable
[easy-medium] similar N303, but in matrix, sum by row and add each row.

322. Coin Change
[medium] i in [0,amount] set MAX, dp[i+j] = min(dp[i+j], dp[i]+1) if i+j<=amount && dp[i]!=MAX.

338. Counting Bits(DP + bit)
[medium] ret[i] = ret[i>>1] + (i&1)  for i in [1,num]

368. Largest Divisible Subset(interesting...)
[medium-hard] DP+backtracking.

375. Guess Number Higher or Lower II
[medium] 2d DP. [TODO]

376. Wiggle Subsequence(interesting)
[medium] alternate DP. if(num[i]>num[i-1])p=q+1; else if(num[i]<num[i-1])q=p+1; return max(p,q);


---------------------------------------------------
Hash Table(reviewed on 9/29/2016)
hashmap can be used as count each char/num, or store index of char/num
hashset usually check if visited or not.
---------------------------------------------------
1. Two Sum
[easy] store (sum-num[i]) and index in hashtable.    map(sum-num[i], index)

3. Longest Substring Without Repeating Characters(interesting)(real question)
[medium-hard] hashtable + sliding window with two pointers. BF is o(n^2), hashtable is o(n).  map(char, index)
map to store index of previous duplicate num[i], update left if found in map, max = (i-left);
left = -1, ret =0;
for(int i=0;i<s.length;i++){
    if(map.contains(s.charAt(i))) left=max(left, map.get(s.charAt(i)));
    ret = max(ret, i-left);
    map.put(s.charAt(i), i);
}

36. Valid Sudoku
[easy-medium] hashtable to store if such number is visited or not.  or hashset store if visited.

166. Fraction to Recurring Decimal
[medium-hard] use hashtable to store visited number, and add brackets before it.

187. Repeated DNA Sequences(find all repeated 10-length string)
[easy-medium] 2 hashsets. one is for seen, if seen, add to ret set.  or count each string, out put count>=2;

202. Happy Number
[easy] put calculated number in hashset to detect duplicate.

205. Isomorphic Strings(Two strings are isomorphic if the characters in s can be replaced to get t.)
[easy-medium] two way hashtables. if(map.put(a[i]),i) != map.put(b[i],i)) return false; Integer i(not int);

290. Word Pattern
[easy-medium] two way hashtables, the same as N205.   map(char, String) and map(String, char)

217. Contains Duplicate(if duplicate integer exist in an array.)
[easy] hashset.

219. Contains Duplicate II(duplicate within k distance)
[easy] hashtable, value and idnex. check distance.  map(num, its index);

220. Contains Duplicate III
[medium-hard]  treeset? [TODO]

299. Bulls and Cows
[easy-medium] need a counter int[] for each number.
if(counter[secret_num]++ < 0) cow++; if(counter[guess_num]-- >0) cow++;
int num_bull=0, num_cow=0;
int[] nums = new int[10];
for(int i=0;i<secret.length();i++){
    if(secret.charAt(i) == guess.charAt(i)) num_bull++;
    else{
        if(nums[secret.charAt(i)-'0']++ < 0) num_cow++;
        if(nums[guess.charAt(i)-'0']--  > 0) num_cow++;
    }
}
return num_bull+"A"+num_cow+"B";


347. Top K Frequent Elements(interesting)
[medium] bucket sort o(n) time but o(n) space: map(count, num). List[] buckets= new List[num.length+1];
heap o(nlogn) time, but o(k) space.

349. Intersection of Two Arrays
[easy] find intersect of two hashset.

350. Intersection of Two Arrays II
[easy-medium] find intersect of two hashtables, value on count of each num.

383. Ransom Note(if "A" can be constructed from "B")
[easy] hashtable, count and compare each char.

387. First Unique Character in a String
[easy-medium] two pass. map(char, count).  return the first count==1 foreach char in str(not map).

389. Find the Difference(find one different char in two strings)
[easy] two pass. 1st: map(char, count)  2ed: count--; return if count<0;


---------------------------------------------------
Linked List
---------------------------------------------------
2. Add Two Numbers
[easy-medium] carry. one list is shorter than the other. extra carry node.

19. Remove Nth Node From End of List
[easy] two pointers, one moves N steps ahead.

21. Merge Two Sorted Lists
[easy] dummy node.

24. Swap Nodes in Pairs(swap adjacent node)
[easy-medium] dummy node.  need three pointers to swap: pre, cur and nextNode.

61. Rotate List
[easy-medium] count node, tail -> head, move n - k steps, head = tail.next, tail.next = null  [TODO]

83. Remove Duplicates from Sorted List
[easy] skip next if equals. if ==, cur.next=cur.next.next, else cur = cur.next.

82. Remove Duplicates from Sorted List II
[medium] need dummy node to skip the first one. store duplicate value by checking cur.next.val == cur.next.next.val , and skip all duplicate if equals duplicate value.

86. Partition List
[medium] two dummy nodes as the start of each list, two p pointers points to current node will end up to the tail of each list.

206. Reverse Linked List
[easy-medium] iterative one. need pre, cur, next.

92. Reverse Linked List II
[medium] dummy node to solve first node issue. need extra pre_m, m_node to link head and tail. pre_m.next = pre, m_node.next=cur.  pre, cur, next for reversing node. m-- >1; n-- >1

141. Linked List Cycle
[easy] two pointers, slow and fast. while(fast!=null && fast.next != null) ...

142. Linked List Cycle II(find entrance of cycle)
[medium] once they meet, reset slow to head, and move them at the same pace, they will meet at the entrance.

143. Reorder List (1->2->3->4   ----->    1->4->2->3)
[medium] find mid point, and reverse the second half, and merge them.

147. Insertion Sort List
[medium] need dummy node.[TODO]

148. Sort List
[medium] merge sort. [TODO]

160. Intersection of Two Linked Lists
[easy-medium] subtract the length of two lists. the longer one moves the diff steps first.

203. Remove Linked List Elements
[easy] dummy node to handle first node or while loop to skip the first node.

234. Palindrome Linked List(require o(1) space)
[easy-medium] reverse the first half while find mid point; compare reversed with slow. [TODO not implemented yet]

237. Delete Node in a Linked List (only access to that node.)
[easy] copy node value. remove the next node.

328. Odd Even Linked List
[easy-medium] one pointer for odd, one pointer for even.


---------------------------------------------------
Math
---------------------------------------------------
7. Reverse Integer
[easy-medium] ret = ret*10 + x%10; x/=10; overflow, negative, trailing zeros?

43. Multiply Strings
[medium] o(n^2), p1 = i+j; p2=i+j+1; sum = product + ret[p2]; ret[p1] += sum /10; ret[p2] = sum % 10;

60, Permutation Sequence.
[medium to hard] math, k / (n-1)! for current number,  k%(n-1)! for next iteration.

168. Excel Sheet Column Title(convert base 10 to base 26)
[easy-medium] construct from right to left, use mod first then divide. n-- to solve non-zero issue.

171. Excel Sheet Column Number(convert base 26 to base 10)
[easy] sum = sum *26 + (s.charAt(i)- 'A' + 1); for(i in [0,n-1])

172. Factorial Trailing Zeroes
[easy] count number of 5s, equal trailing zeros. time o(log5)

223. Rectangle Area
[easy-medium] overlap(sum of 2 separate - overlap area) vs non-overlap(sum of 2 separate area).

258. Add Digits
[easy] digital root. ret = n%9; if ret==0; return 9;

263. Ugly Number[code is N262]
[easy] while loop (n/=5, n/=3, n/=2) return n==1;

264. Ugly Number II(interesting one.)
[medium] DP. maintain l1, l2, l3 in dp[], next k =  min(dp[l1]*2, dp[l2]*3, dp[l3]*5);

292. Nim Game(grab 1-3 stones, grab the last one win, you take the first grab.)
[easy] you lose only when remains 4*n;

319. Bulb Switcher
[medium] return (int)Math.sqrt(n);

231. Power of Two(use bit)
[easy] return n>0 && (n & n-1) == 0;

326. Power of Three
[easy] recursively divide 3.

342. Power of Four
[easy] recursively divide 4.

343. Integer Break
[easy-medium] choose from [0,2] of 2, the rest should be 3.

357. Count Numbers with Unique Digits
[medium] f(k) = 9 * 9 * 8 * ... (9 - k + 2) [TODO]

365. Water and Jug Problem
[medium] return z % gcd(x,y) == 0; gcd{while (b!=0){ a=b; b=a%b} return a; }

367. Valid Perfect Square(9=1+3+5 ...)
[medium] tmp=1; while(num>0) num -= tmp; tmp+=2; return num==0;


---------------------------------------------------
Palindrome(DFS + backtracking or DP)
---------------------------------------------------
https://leetcode.com/articles/longest-palindromic-substring/#approach-5-manachers-algorithm-accepted    Manacher's Algorithm
5	Longest Palindromic Substring

9	Palindrome Number
[easy-medium], create div the same digits as number, use it to get left digit

125	Valid Palindrome
[easy-medium], consider case and special chars. two pointers start from left and right end.

131 Palindrome Partitioning
[medium-hard] DP to find all palindrome of sub-strings, DFS+backtracking.

132 Palindrome Partitioning II
[hard] DP cut[j] = min(cut[j], cut[i-1] + 1) inside a[i] == a[j] condition.  [TODO]

214	Shortest Palindrome
[hard] String, recursive. prefix, suffix and middle. [TODO]

234	Palindrome Linked List
[easy] o(n) space,  [medium] o(1) space. reverse first half list. [TODO]

266	Palindrome Permutation    (locked)
267	Palindrome Permutation II (locked)

336	Palindrome Pairs
[hard] hashtable + divide conquer. split each words str1 and str2, and check if isPal(str2) and reversed(str2) in map. [TODO]



---------------------------------------------------
Random
---------------------------------------------------
382. Linked List Random Node
[medium] save list to array, and call random. o(n) space
follow up: o(1) space, see Reservoir Sampling [TODO]






---------------------------------------------------
Sort
---------------------------------------------------
179. Largest Number
[medium] custom sort base on String desc (330 before 303)
Collections.sort(list, new Comparator<Integer>(){
    public int compare(Integer a, Integer b){
        return (""+b+a).compareTo(""+a+b);
    }
});


215. Kth Largest Element in an Array
[medium] heap or quicksort.




---------------------------------------------------
Stack/Queue(reviewed on 9/29/2016)
---------------------------------------------------
20. Valid Parentheses
[easy] push if it's "(""; else pop if it's ")"; empty case.
could also count++ if "("; count-- if ")"; return false if count<0;

71. Simplify Path
[medium] pop if it's "..", continue if it's '.', else push

150. Evaluate Reverse Polish Notation
[easy] if operand, pop twice and evaluate and push back, else push.

155. Min Stack(tricky)
[easy-medium] two stacks. one for regular pop, push and top. another to store min_values,
push only when incoming is smaller than top, pop only when val = top.
used the trick of stack's top always be the smallest until a smaller comes after.

225. Implement Stack using Queues
[easy-medium] two queues to mimic stack.

232. Implement Queue using Stacks
[easy-medium] two stacks to mimic queue.


224. Basic Calculator [TODO]
[hard]

227. Basic Calculator II [TODO]
[mmedium]




---------------------------------------------------
String
---------------------------------------------------
5. Longest Palindromic Substring(interesting)
[medium-hard] BF is o(n^3). Manacher's Algorithm is o(n)  [TODO]
for each i, call isPal(i,i) and isPal(i,i+1) o(n^2)

6. ZigZag Conversion(interesting)
[easy-medium] need StringBuilders[], sb[index]=c; index ++ or -- to put c in different row of sb.
offset=1 reached first SB; offset=-1 when reached last SB. index+=offset

8. String to Integer (atoi)
[easy-medium] detail coding. leading/trailing spaces, negative sign, non-chars, overflow?

12. Integer to Roman
[medium]
String[] symbol={"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
int[]     value={1000,900,500,400, 100, 90,  50, 40,  10, 9,   5,  4,   1};
StringBuilder sb = new StringBuilder();
for(int i=0;num!=0; i++){
    while(num >= value[i]){
        num -= value[i];
        sb.append(symbol[i]);
    }
}

13. Roman to Integer(hard on find the pattern)
[easy-medium] sum-=num[i] if num[i] < num[i+1]; else sum+=num[i]

14. Longest Common Prefix
[easy-medium] vertical scan each char in all strings and compare.

38. Count and Say
[easy-medium] count duplicate num and construct count+"i" set to next string.



67. Add Binary
[easy-medium]  two pointers in one loop, while they >=0

151. Reverse Words in a String
[easy-medium] trim().split(" +") to String[]. and reverse it.  or manual scan word, and reversely append word.

165. Compare Version Numbers
[easy-medium] problem says 1.22 > 1.3 because 22 > 3. sum digits up and compare.



---------------------------------------------------
Two pointers(or Three pointers)
---------------------------------------------------
11. Container With Most Water
[medium-easy] two pointers on left and right. min_height=min(num[left],num[right]), maxArea=max(maxArea, (right-left)*min_height); left++ while num[left] <= min_height ...

167. Two Sum II - Input array is sorted
[easy] two pointers. l++ and r--;

15. 3Sum
[medium-easy] BF(n^3). sort+two pointer makes it o(n^2). skip duplicate.

16. 3Sum Closest
[medium-easy] similar to N15 3sum. store ret and min_diff.

18. 4Sum
[medium] similar to N15 3sum. o(n^3)



26. Remove Duplicates from Sorted Array
[easy-medium] i points to last unique one, if (num[i]!=num[j]) num[++i] = num[j]

27. Remove Element(remove given val)
[easy-medium] similar to N26, but i points to last removable one. if (num[i] != val) num[i++] = num[j]  //num[++i]=x and num[i++]=x are different

28. Implement strStr()
[easy-medium] BF is faster than KMP in most small cases. while(i<sizeA && j<sizeB) if(A[i]==B[j]){i++;j++;} else {i=i-j+1;j=0}

58, Length of Last Word.
[very easy] String operation. scan from last. o(n)

75. Sort Colors
[easy-medium] three pointers. if 0, swap(i++,left++), if 2, swap(i,right--), else i++; while(i<=right)

26. Remove Duplicates from Sorted Array
[easy-medium] i as the end of array, compare it with num[j], if equal continue j and skipped num[j],
else num[++i] = nums[j],  return i+1

80. Remove Duplicates from Sorted Array II
[easy-medium] similar to 26, compare with num[i-1] rather than num[i]. j starts from 2.


209. Minimum Size Subarray Sum(N203 in my Java code)
[medium] sliding window. window [i,j] >= sum; while([i++,j]>=sum, ret= min(ret, j-i+1))


228. Summary Ranges(given [0,1,2,4,5,7], return ["0->2","4->5","7"].)
[easy-medium] maintain start index, if num[i]-num[i-1] >1, construct list(start,i-1); start=i;   (may overflow num[i]-num[i-1])

283. Move Zeroes
[easy] move all non-zeros to front and fill zeros at the end.

344. Reverse String
[easy]

345. Reverse Vowels of a String
[easy] two pointers find vowels and swap.




---------------------------------------------------
Trie
---------------------------------------------------
208. Implement Trie (Prefix Tree)
[medium-hard] class Trie{Trie[] children; boolean isEnd;}

211. Add and Search Word - Data structure design
[medium-hard] BFS on trie of wildcard(.)


