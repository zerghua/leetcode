---------------------------------------------------
Anagram(words group like: cat, act)
---------------------------------------------------
49	Group Anagrams
[medium] sorted string in hashtable, hm<String, List<>>, or Arrays.hashCode(int[])  [TODO]

242	Valid Anagram
[easy] hashtable or sort string.  [TODO]




---------------------------------------------------
Array
---------------------------------------------------
53	Maximum Subarray,  max continous subarray.  condition on if local_max >0.
[easy]

54	Spiral Matrix.  4 loops of top,right,bottom and left side.
[medium to code]

55. Jump Game.  array operation. o(n), scan each item and exit early if possible.
[easy]

58, Length of Last Word. String operation. scan from last. o(n)
[very easy]

59, Spiral Matrix 2. 4 loops of top,right,bottom and left side.
[medium to code]

66. Plus One
[easy-medium]  find pattern. test case, 199, 999, 288, create new array only when like 999

73. Set Matrix Zeroes
[medium] o(1) space.  1. record if the first row/col should should set to 0, 2. then use them to store this row/col should be set to 0, 3. set every cell, 4. set first row/col according to step 1.

88. Merge Sorted Array
[easy] fill from the end of array.

118. Pascal's Triangle
[easy] find pattern. similar to tree level order traversal.

119. Pascal's Triangle II(find kth row, but only o(k) space)
[easy-medium] rolling array, scan from backward.





---------------------------------------------------
Binary search
---------------------------------------------------
69. Sqrt(x)
[easy-medium] return left bound. negative number has not sqrt, use Long to handle overflow.

74. Search a 2D Matrix
[easy-medium] val = matrix[mid/col][mid%col]

33. Search in Rotated Sorted Array
[hard] 4 if conditions, compare num[mid] with num[left], and further compare target to num[left] and num[mid].

81. Search in Rotated Sorted Array II (duplicate in array)
[hard] similar to 33, left++ if num[left] = num[mid]. worst case o(n)



---------------------------------------------------
Binary Tree
---------------------------------------------------
94. Binary Tree Inorder Traversal
[easy-medium] left-root-right. iterative, use stack. push p to stack if p is not null then p=p.left,  else if p==null, store stack.pop().val, and then p = p.right. while(p!=null || !s.isEmpty)

100. Same Tree
[easy] DFS. return true if p == null && q==null, false if p==null || q==null, if p.val == q.val return dfs(p.left, q.left) && dfs(p.right, q.right) else return false

101. Symmetric Tree
[easy-medium] DFS or BFS. DFS compare left.val == right.val && dfs(left.left, right.right) && dfs(left.right, right.left).   BFS, two queues, lq.push(left,right), rq.push(right,left).

102. Binary Tree Level Order Traversal
[easy] BFS use queue, store size of each level. DFS pass level as argument.

107. Binary Tree Level Order Traversal II (return bottom up result)
[easy] almost the same as 102, just change ret.add(list) to ret.add(0,list);

103. Binary Tree Zigzag Level Order Traversal
[medium] 1. could reverse odd number of list with 102 solution. Collections.reverse(res.get(i));   2. use two stacks.

104. Maximum Depth of Binary Tree
[easy] DFS.  1 + max(dfs(node.left), dfs(node.right)). if(node ==null) return 0;

105. Construct Binary Tree from Preorder and Inorder Traversal
[medium] DFS. dfs(int[] preoder, int preorder_start, int preorder_end, int[] inorder, int inorder_start, inorder_end) if(preorder_start>preorder_end) return null, if (preorder_start==preorder_end) return new TreeNode(preorder[preorder_start]); else build it and recursive on left and right.

106. Construct Binary Tree from Inorder and Postorder Traversal
[medium] DFS. similar to 105.

110. Balanced Binary Tree
[easy-medium] DFS, if node ==null, return 0.  left_height = dfs(node.left), if(left_height==-1) return -1 ...  return 1+ max(left_height, right_height).

111. Minimum Depth of Binary Tree
[easy-medium] DFS. if(node.left==null || node.right==null) return 1 + max(dfs(node.left), dfs(node.right)),  else return 1 + min(dfs(node.left), dfs(node.right))

112. Path Sum
[easy-medium] DFS. if(root == null) return false;  if(root.val == sum && root.left ==null && root.right == null) return true; return dfs(root.left, sum-root.val) || dfs(root.right, sum-root.val)

113. Path Sum II
[medium] DFS + backtracking. pass along ret and cur_list. return condition is the same as 112. cur_list.add(root.val); dfs(ret, root.left, cur_list, sum-root.val); cur_list.remove(root.val)
 ... the same goes for right node.

114. Flatten Binary Tree to Linked List
[medium-hard] Morris Algorithm?  [TODO]

116. Populating Next Right Pointers in Each Node
117. Populating Next Right Pointers in Each Node II
[medium] share the same BFS level order traversal solution. with extra line of: if(i<size-1) node.next = q.peek(); for this linking next node.



---------------------------------------------------
Binary Search Tree
---------------------------------------------------
96. Unique Binary Search Trees
[medium-hard] DP. catalan number. f(n) = f(0)*f(n-1) + f(1)*f(n-2) + ... + f(n-1)f(0)

95. Unique Binary Search Trees II
[medium-hard] DFS. foreach(start,n), left = (start,i-1), right=(i+1,n).

98. Validate Binary Search Tree
[easy-medium] DFS. pass along min, max value to validate. return false if root.val>=max || root.val <= min. then return dfs(root.left,min, root.val) && dfs(root.right,root.val, max).

108. Convert Sorted Array to Binary Search Tree
[easy] DFS. dfs(int[] a, int start, int end), if(start>end) return null. else build tree. mid = (left+right)/2  ...

109. Convert Sorted List to Binary Search Tree
[medium] 1. convert list to array.  2. two pointers find mid point each loop. 3. global pointer, very tricky, see 109 solution.



---------------------------------------------------
Bit Manipulation
---------------------------------------------------
89. Gray Code
[medium] f(n) += reverse(f(n-1)) + 2^(n-1), use list to represent f(n)




---------------------------------------------------
DFS + backtracking
---------------------------------------------------
46  Permutations
47  Permutations II (contains duplicates)

78  Subsets(distinct numbers)
[medium] add all cur_list to ret in loop, cur_list as backtrack.

90  Subsets II (contains duplicates)
[medium] add all cur_list to ret in loop, sort and skip duplicate when i>start && num[i-1]=num[i]


39  Combination Sum
40  Combination Sum II (can't reuse same element)
216 Combination Sum III
377 Combination Sum IV

77  Combinations
[medium] return when size==k. return part of the subsets problem. cur_list as backtrack.


79. Word Search (Is a word in matrix)
[medium] 4 recursive calls inside one function. need visited[][] as backtrack, conditional and boundary check.

93. Restore IP Addresses
[medium] extra in level parameter to record which level we are in, use it for termination. pruning code for IP address like 00, 01, early break.





---------------------------------------------------
DP
---------------------------------------------------
62. Unique Paths
[easy] dp[i][j] = dp[i-1][j] + dp[i][j-1]

63. Unique Paths II
[easy-medium]  rolling array.  dp[j] += d[j-1]  when j>0

64. Minimum Path Sum
[easy]  dp[j] = min(dp[j-1], dp[j]) + grid[i][j].  similar to 62, but use rolling array(o(m) space).

70, climb stairs. (either 1 step or 2 steps)
[easy-medium]   dp[i] = dp[i-2] + dp[i-1].  or c= a+b, a=b, b=c

91. Decode Ways
[medium] dp[i] = dp[i-1] + dp[i-2] if substring(i-1,i) and substring(i-2,i) is valid dp[0]=dp[1]=1






---------------------------------------------------
Linked List
---------------------------------------------------
61. Rotate List
[easy-medium] count node, tail -> head, move n - k steps, head = tail.next, tail.next = null  [TODO]

83. Remove Duplicates from Sorted List
[easy] skip next if equals. if ==, cur.next=cur.next.next, else cur = cur.next.

82. Remove Duplicates from Sorted List II
[medium] need dummy node to skip the first one. store duplicate value by checking cur.next.val == cur.next.next.val , and skip all duplicate if equals duplicate value.

86. Partition List
[medium] two dummy nodes as the start of each list, two p pointers points to current node will end up to the tail of each list.

206. Reverse Linked List
[easy-medium] iterative one. need pre, cur, next.

92. Reverse Linked List II
[medium] dummy node to solve first node issue. need extra pre_m, m_node to link head and tail. pre_m.next = pre, m_node.next=cur.  pre, cur, next for reversing node. m-- >1; n-- >1



---------------------------------------------------
Math
---------------------------------------------------
60, Permutation Sequence.
[medium to hard] math, k / (n-1)! for current number,  k%(n-1)! for next iteration.




---------------------------------------------------
Palindrome(DFS + backtracking or DP)
---------------------------------------------------
https://leetcode.com/articles/longest-palindromic-substring/#approach-5-manachers-algorithm-accepted    Manacher's Algorithm
5	Longest Palindromic Substring

9	Palindrome Number
[easy-medium], create div the same digits as number, use it to get left digit

125	Valid Palindrome
[easy-medium], consider case and special chars.

131 Palindrome Partitioning
[medium-hard] DP to find all palindrome of sub-strings + DFS+backtracking.

132 Palindrome Partitioning II
[hard] DP cut[j] = min(cut[j], cut[i-1] + 1) inside a[i] == a[j] condition.  [TODO]

214	Shortest Palindrome
[hard] String, recursive. prefix, suffix and middle. [TODO]

234	Palindrome Linked List
[easy] o(n) space,  [medium] o(1) space. reverse first half list. [TODO]

266	Palindrome Permutation    (locked)
267	Palindrome Permutation II (locked)

336	Palindrome Pairs
[hard] hashtable + divide conquer. split each words str1 and str2, and check if isPal(str2) and reversed(str2) in map. [TODO]




---------------------------------------------------
Stack
---------------------------------------------------
71. Simplify Path
[medium] pop if it's "..", continue if it's '.', else push



---------------------------------------------------
String
---------------------------------------------------
67. Add Binary
[easy-medium]  two pointers in one loop, while they >=0



---------------------------------------------------
Two pointers(or Three pointers)
---------------------------------------------------
75. Sort Colors
[easy-medium] three pointers. if 0, swap(i++,left++), if 2, swap(i,right--), else i++; while(i<=right)

26. Remove Duplicates from Sorted Array
[easy-medium] i as the end of array, compare it with num[j], if equal continue j and skipped num[j],
else num[++i] = nums[j],  return i+1

80. Remove Duplicates from Sorted Array II
[easy-medium] similar to 26, compare with num[i-1] rather than num[i]. j starts from 2.

