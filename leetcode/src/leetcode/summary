Table of Contents(last reviewed on)
1.Array                      9/5/2017
2.String                     12/1/2016
3.Matrix
4.Two pointers               12/1/2016
5.Sliding Window             12/1/2016
6.Sort                       12/1/2016
7.Binary search              9/5/2017
8.Greedy                     9/7/2017
9.DP                         10/2/2016
10.Random                    9/7/2017
11.Linked List               10/27/2016
12.Hashmap                   9/7/2017
13.Stack/Queue               9/7/2017
14.Heap
15.Interval                  10/27/2016
16.Binary Tree               9/5/2017
17.BST(Binary Search Tree)   9/6/2017
18.Augmented Tree            9/5/2017
19.BFS
20.DFS
21.Divide and conquer        9/7/2017
22.Graph(Topological sort)
23.Union Find
24.Backtracking              9/6/2017
25.Design                    9/6/2017
26.Math                      10/27/2016
27.Bit Manipulation          9/6/2017
28.hard questions


TODO: gather all dfs tree problems and have a taste of top-down and bottom-up difference.




---------------------------------------------------
1.Array (reviewed on 9/29/2016, 10/27/2016, 9/5/2017)
// for array problem, if sort is not efficient enough, use hash table or two pointers/sliding window
// if sorted or adjacent/continuous graph , it's usually binary search.
---------------------------------------------------
561. Array Partition I
[]

565. Array Nesting
[]

611. Valid Triangle Number
[] two pointers.

645. Set Mismatch
[]

656. Coin Path
[]

658. Find K Closest Elements
[] o(n)?

665. Nondecreasing Array
[]

667. Beautiful Arrangement II
[]

670. Maximum Swap
[]


31. Next Permutation(hard on find the pattern)
[medium-hard] array, swap and reverse,
right->left, find i where a[i] < a[i+1]; right->left, find a[j] > a[i], swap a[i] and a[j], reverse [i+1, end]

48. Rotate Image(rotate 90 degree of matrix)
[medium-easy] in-place solutions: 1.reverse each row [0,n), then swap matrix char(m[i][j] ~= m[j][i]) in diagonal;
2. 4-way rotation.

189. Rotate Array
[easy] reverse 3 times. reverse(0,n-k-1); reverse(n-k,n-1); reverse(0,n-1)


54. Spiral Matrix(return array of spiral order, outer-->inner clockwise)(real question)
[medium] 4 loops of top,right,bottom and left side.

59. Spiral Matrix II(generate spiral n^2 matrix)
[medium] 4 loops of top,right,bottom and left side.

58. Length of Last Word(return the length of last word in the string)
[easy] scan from last find first empty char.

66. Plus One(to an array of digits)(real question)
[easy-medium]  find pattern. test case, 199, 999, 288, create new array only when like 999
for(int i=digits.length-1;i>=0;i--){
    if(digits[i] != 9 ){
        digits[i]++;
        return digits;
    }
    digits[i]=0;
}
// create new array if comes to here. like 999+1, return 1000
int[] ret = new int[digits.length+1];
ret[0]=1;
return ret;


73. Set Matrix Zeroes(require o(1) space.)
[medium]
1. record if the first row/col should should set to 0,
2. then use them to store this row/col should be set to 0,
3. set every cell,
4. set first row/col according to step 1.

88. Merge Sorted Array
[easy] fill from the end of array.

118. Pascal's Triangle(generate it. [1],[1,1],[1,2,1],[1,3,3,1]...)
[easy] find pattern. similar to tree level order traversal. use previous list to construct current list.

*119. Pascal's Triangle II(find kth row, but only o(k) space)
[easy-medium] rolling array, scan from backward.
Integer[] row = new Integer[rowIndex+1];
Arrays.fill(row, 1);
for(int i=1; i<=rowIndex;i++){
    for(int j= i-1;j >= 1;j--){  // only works if backward
        row[j] += row[j-1];
    }
}
return Arrays.asList(row);

169. Majority Element(majority > n/2)
[easy-medium] counting number, count++ if the same; else count--; if count==0, ret=num[i], count=1
because majority > n/2, so it will always win with such counting.
int majorElement=nums[0];
int count=1;
for(int i=1;i<nums.length;i++){
    if(majorElement == nums[i]) count++;
    else count -- ;

    if(count == 0) {
        majorElement = nums[i];
        count=1;
    }
}
return majorElement;

186. Reverse Words in a String II(reverse the string word by word, separated by space)
[medium] reverse and reverse(in place)

229. Majority Element II(find out numbers exists times > n/3) Boyer_Moore_majority_vote_algorithm
[medium-hard] 2 variables to hold number, 2 counters.

228. Summary Ranges(given [0,1,2,4,5,7], return ["0->2","4->5","7"])(interesting)
[medium] maintain start index.
if num[i]-num[i-1] >1, construct list(start,i-1); start=i;  (may overflow num[i]-num[i-1])(corner case last one)
    for(int i=0;i<nums.length;i++){
        int start = nums[i];
        while(i<nums.length-1 && nums[i] + 1 == nums[i+1]) i++; // key here

        if(start == nums[i]) ret.add(start + "");
        else ret.add(start + "->" + nums[i]);
    }


238. Product of Array Except Self(can't use divide, require o(n) time) (tricky, kind of DP.)
[medium] two pass from left and right. product of all its left and right.
1st pass: ret[i] = num[i+1]*ret[i+1]; 2ed pass: ret[i] *= left_sum; left_sum *= nums[i];

243. Shortest Word Distance(return the shortest distance between these two words in the list)
[medium] two pointers. update and compare their distance each step.

245. Shortest Word Distance III(with duplicate)
[medium] if(word2 == word1) {p1 = p2; p2 = i;} basically p2 contains the latest, p1 has the leftover of p2.

259. 3Sum Smaller(return total count of sum of different 3 numbers less than k)
[easy] sort + two pointers. o(n^2), BF is o(n^3)

274. H-Index[TODO]
[medium] sort o(nlogn), return i if reversed sorted a[i]<=i;
hashtable o(n) time, count each a[i], store in stat[], from [n,0) sum+=stat[i]; return i if sum>=i;

275. H-Index II(arrays is sorted, require logn)
[medium] binary search.
while(left<=right){
    int mid = (right-left)/2 + left;
    if(citations[mid] ==  n - mid) return n-mid;
    else if(citations[mid] < n -mid) left = mid+1;
    else right = mid-1;
}
return n-left;

280. Wiggle Sort(Given an unsorted array nums, reorder it in-place such that nums[0] <= nums[1] >= nums[2] <= nums[3])
[medium] greedy swap.


289. Game of Life(require in-place, smart!!!)
[medium] use second bit in int to store next state. 0 --> 00 or 10,  1--> 01 or 11.

321. Create Maximum Number
[hard] array?


324. Wiggle Sort II
[medium] sort and rearrange. [NOT easy to understand.]
array, sort + swap. with duplicate;
    left=(n-1)/2, right=n-1;
    for(int i=0;i<nums.length;i++){
        tmp[i] = (i & 1) == 0 ? nums[left--] : nums[right--];
    }

334. Increasing Triplet Subsequence(3 increasing variables exists or not)
[easy-medium] a,b variables; each n compare with them and update. return true if larger than both
    int a=Integer.MAX_VALUE, b = Integer.MAX_VALUE;
    for(int z : nums){
        if( z <= a) a = z;       // if pass this, guarantee to be larger than a
        else if(z <= b) b = z;   // if pass this, guarantee to be larger than b
        else return true;
    }


335. Self Crossing
[medium]


414. Third Maximum Number(similar to N334)
[easy-medium] find distinct third largest.
    public int thirdMax(int[] nums) {
        Integer first, second, third;
        first = second = third = null;
        for(int n : nums){
            if( (first != null && first == n) || (second!= null && second == n) || (third!=null && third == n)) continue;  //to skip duplicate
            if(first == null || n > first){
                third = second; second = first; first = n;
            }else if(second == null || n > second ){
                third = second; second = n;
            }else if(third == null || n > third){
                third = n;
            }
        }
        return third == null? first : third;
    }


360. Sort Transformed Array
[medium] math.

370. Range Addition
[medium]

373. Find K Pairs with Smallest Sums
[medium] BF heap time o(n^2).
optimized o(klogk), put min(k, num1.length) to heap(sorted by sum increasing and also num2's index)
    while(k-- > 0 && !que.isEmpty()){
        int[] cur = que.poll();
        res.add(new int[]{cur[0], cur[1]});
        if(cur[2] == nums2.length-1) continue;
        que.offer(new int[]{cur[0],nums2[cur[2]+1], cur[2]+1});
    }

378. Kth Smallest Element in a Sorted Matrix
[medium] heap. put the first row in heap, poll from heap, push back with row++; heap<Node(x,y,val)> similar to N373

393. UTF-8 Validation
[medium] find pattern.
    for(int n : data){
        if(count == 0){
            if( (n>>5) == 0b110) count = 1;
            else if ((n>>4) == 0b1110) count = 2;
            else if ((n>>3) == 0b11110) count = 3;
            else if ( (n>>7) == 1) return false; //fail if not one byte.
            //else,  OK if it's one byte
        }else{
            if( (n>>6) != 0b10) return false;
            count--;
        }
    }



412. Fizz Buzz
[easy] very easy.

442. Find All Duplicates in an Array
[medium] nums[index] *= -1; mark the number in it's index to negative
    for(int i=0;i<nums.length;i++){
        int index = Math.abs(nums[i]) - 1;
        if(nums[index] < 0) ret.add(Math.abs(nums[i]));
        else nums[index] *= -1;
    }

448. Find All Numbers Disappeared in an Array(similar to N442)
[easy-medium]
    for(int i=0;i<nums.length;i++){
        int index = Math.abs(nums[i]) - 1;    //Math.abs are important
        if(nums[index] > 0) nums[index] = -nums[index];
    }

    List<Integer> ret = new ArrayList();
    for(int i=0;i<nums.length;i++){
        if(nums[i] >0) ret.add(i+1);
    }


457. Circular Array Loop
[medium]


463. Island Perimeter
[easy-medium] island*4 - neighbour*2; only count right and down neighbours.


485. Max Consecutive Ones
[easy]

495. Teemo Attacking
[easy]

506. Relative Ranks
[easy] sort


---------------------------------------------------
2.String(reviewed on 9/29/2016, 12/1/2016)
---------------------------------------------------
537. Complex Number Multiplication
[medium]

541. Reverse String 2
[]

551. Student Attendance Record 1
[easy]

555. Split Concatenated Strings
[]

557. Reverse Words In A String 3
[easy]

591. Tag Validator
[]

616. Add Bold Tag in String
[]

640. Solve the Equation
[] regex?

647. Palindromic Substrings
[]

657. Judge Route Circle
[easy]





6. ZigZag Conversion(interesting)
[easy-medium] need StringBuilders[], sb[index]=c; index ++ or -- to put c in different row of sb.
offset=1 reached first SB; offset=-1 when reached last SB. index+=offset
StringBuilder[] sb = new StringBuilder[numRows];
for(int i=0;i<numRows;i++) sb[i] = new StringBuilder();

int index=0, offset=1;
for(char c: s.toCharArray()){
    sb[index].append(c);
    if(index == 0) offset = 1;
    else if(index == numRows-1) offset = -1;
    index += offset;
}

StringBuilder ret = new StringBuilder();
for(int i=0;i<numRows;i++) ret.append(sb[i]);
return ret.toString();

8. String to Integer (atoi) (real question)
[easy-medium] str.chatAt(i)-'0'
detail coding. leading/trailing spaces, negative/positive sign, non-chars, overflow/underflow?

12. Integer to Roman(real question)
[medium]
String[] symbol={"M","CM","D","CD","C","XC","L","XL","X","IX","V","IV","I"};
int[]     value={1000,900,500,400, 100, 90,  50, 40,  10, 9,   5,  4,   1};
StringBuilder sb = new StringBuilder();
for(int i=0;num!=0; i++){ //important num!=0
    while(num >= value[i]){
        num -= value[i];
        sb.append(symbol[i]);
    }
}

13. Roman to Integer(hard on find the pattern)(real question)
[easy-medium] sum-=num[i] if num[i] < num[i+1]; else sum+=num[i]

14. Longest Common Prefix
[easy] vertical scan each char in all strings and compare.

38. Count and Say(real question)(facebook)
[easy-medium] count duplicate num and construct count+"i" set to next string.
String ret = "1"; //base case when n=1
int count=1;
for(int j=1;j<n;j++){
    StringBuilder sb = new StringBuilder();
    for(int i=0;i<ret.length();i++){
        if(i<ret.length()-1 && ret.charAt(i) == ret.charAt(i+1)){
            count++;
        }else{
            sb.append(count+ ""+ret.charAt(i));
            count=1;
        }
    }
    ret = sb.toString();
}


67. Add Binary(return sum of two binary number of String)
[easy-medium]  from right to left. sum+=str.chatAt(i)-'0'; sum+=str.chatAt(j)-'0'; carry=sum/2;

415. Add Strings(real question)(google, add two arrays)
[easy] similar to N2(add linked list) and N67.

165. Compare Version Numbers
[easy-medium] problem says 1.22 > 1.3 because 22 > 3. build num between '.';
int i=0,j=0;
char[] c1 = version1.toCharArray(), c2 = version2.toCharArray();
while(i<c1.length || j<c2.length){
    int num1=0, num2=0;
    while(i<c1.length && c1[i] != '.') num1 = num1*10 + c1[i++] -'0';
    while(j<c2.length && c2[j] != '.') num2 = num2*10 + c2[j++] -'0';
    if(num1 > num2) return 1;
    if(num1 < num2) return -1;
    i++;j++;
}
return 0;

161. One Edit Distance(decide if two string are one char diff)(real question, VIP)[must]
[medium] 3 valid cases.
1. s="abc" t="aXc"(modify, same length); 2. s="abc" t="abcX"(append);  3. s="abc" t="abXc"(insert)
public boolean isOneEditDistance(String s, String t){
    int m = s.length, n = t.length;
    if(m>n) return isOneEditDistance(t,s); //make sure s is shorted than t
    int i=0, diff = n-m;
    if(diff>1) return false;
    while(i<m && s.charAt(i) == t.charAt(i))i++;
    if(i==m) return diff == 1; //append case, return false if s==t
    if(diff == 0) i++; // for modify case
    while(i<m && s.charAt(i) == t.charAt(i+diff)) i++; //insert and modify case.
    return i==m;
}

246. Strobogrammatic Number(6<->9, 0<->0, 1<->1, 8<->8)
[easy] similar to isPalindrome, two pointers

293. Flip Game
[easy] flip two adjacent chars.


306. Additive Number(return if a string is additive number,  199100199 is because [1, 99, 100, 199])
[medium-hard] boolean = DFS(num_string, left_int, right_int, first_num_int)
complicate on how to extract 3 numbers. [TODO]


408. Valid Word Abbreviation
[medium]


434. Number of Segments in a String
[easy] finite state machine.
int ret=0, state=1;
for(char c: s.toCharArray()){
    if(c == ' ') state = 1;
    else if(state == 1){
        ret++;
        state = 0;
    }
}

459. Repeated Substring Pattern
[easy-medium] build divisible substring and compare with original.
int size = str.length();
for(int i=size/2;i>=1;i--) {
    if (size % i == 0) {
        String sub = str.substring(0, i);
        StringBuilder sb = new StringBuilder();
        for (int j = 0; j < size / i; j++) sb.append(sub);
        if (sb.toString().equals(str)) return true;
    }
}

467. Unique Substrings in Wrap around String
[medium]


468. Validate IP Address
[medium] interesting. take a look.

481. Magical String
[medium]

482. License Key Formatting
[easy]

484. Find Permutation
[medium]

520. Detect Capital
[medium]

521. Longest Uncommon Subsequence I
[easy]

522. Longest Uncommon Subsequence II
[medium]

524. Longest Word in Dictionary through Deleting
[medium]

---------------------------------------------------
3.Matrix
---------------------------------------------------
311. Sparse Matrix Multiplication
[medium]

361. Bomb Enemy
[medium] kind of DP.

363. Max Sum of Rectangle No Larger Than K
[hard] treemap

391. Perfect Rectangle
[hard]

422. Valid Word Square
[easy]

498. Diagonal Traverse
[medium]

566. Reshape the Matrix
[medium]

598. Range Addition II
[]

624. Maximum Distance in Arrays
[]

661. Image Smoother
[]



---------------------------------------------------
4.Two pointers(or Three pointers)(reviewed on 10/1/2016, 12/1/2016)
---------------------------------------------------
11. Container With Most Water(interesting)
[medium-easy] two pointers on left and right.
while(left < right){
    int min = Math.min(height[right] , height[left]);
    max = Math.max(max,  min * (right-left));

    while(left<right && height[left]<= min) left++;
    while(left<right && height[right]<= min) right--;
}

167. Two Sum II - Input array is sorted
[easy] two pointers. l++ and r--;

15. 3Sum(real question)
[medium-easy] BF(n^3). sort+two pointer makes it o(n^2). skip duplicate.
Arrays.sort(nums);
for(int i=0; i<nums.length-2;i++){
    if(i>0 && nums[i] == nums[i-1]) continue; //skip duplicate of i

    int left = i+1, right = nums.length-1;
    while(left < right) {
        int sum = nums[i] + nums[left] + nums[right];
        if (sum == 0) {
            ret.add(Arrays.asList(nums[i], nums[left], nums[right]));
            left++; right--;

            // skip duplicate of left and right
            while(left<right && nums[left] == nums[left-1]) left++;
            while(left<right && nums[right] == nums[right+1]) right--;
        }
        else if (sum > 0) right--;
        else left++;
    }
}


16. 3Sum Closest
[medium-easy] similar to N15 3sum. store ret and min_diff.
for(int i=0; i< nums.length-2; i++){
    int start = i+1, end=nums.length-1;
    while(start < end){
        int sum = nums[i] + nums[start] + nums[end];
        if(sum == target) return target;
        else if(sum< target) start++;
        else end--;

        int cur_diff = Math.abs(sum-target);
        if( cur_diff < min_diff) {
            min_diff = cur_diff;
            ret = sum;
        }
    }
}


18. 4Sum(prepare for ksum, DFS+backtracking)
[medium] similar to N15 3sum. o(n^3)

26. Remove Duplicates from Sorted Array
[easy-medium] i points to last unique one.
int i=0;
for(int n: nums){
    if(n != nums[i]) nums[++i] = n;
}
return i+1;


80. Remove Duplicates from Sorted Array II(duplicate allows twice)
[easy-medium] similar to 26, compare with num[i-1] rather than num[i].
int i=1;
for(int j=2;j<nums.length;j++){
    if(nums[i-1] != nums[j]) nums[++i] = nums[j];
}
return i+1;


27. Remove Element(remove given val)(real question)
[easy-medium] similar to N26, but i points to last removable one.
int i=0;
for(int n: nums){
    if(n != val) nums[i++] = n;
}
return i;


283. Move Zeroes
[easy-medium] similar to N27. if (num[i] != 0) num[i++] = num[j], and fill zeros to the end.
int i=0;
for(int n: nums){
    if(n != 0) nums[i++] = n;
}
for(int j=i;j<nums.length;j++) nums[j] = 0;


28. Implement strStr()
[easy-medium] BF is faster than KMP in most small cases.
while(i<sizeA && j<sizeB) if(A[i]==B[j]){i++;j++;} else {i=i-j+1;j=0}; return i-j if j==sizeB.
int i=0, j=0;
char[] t = haystack.toCharArray();
char[] p = needle.toCharArray();
while(i<t.length && j<p.length){
    if(t[i] == p[j]){
        i++;
        j++;
    }else{
        i = i-j+1;
        j = 0;
    }
}
int ret = -1;
if(j==p.length) ret = i-j;
return ret;


58, Length of Last Word.
[very easy] String operation. scan from last. o(n)
for(int i=s.length()-1; i>=0;i--){
    if(s.charAt(i) != ' ') ret++;
    else if(ret != 0) break;  // trailing spaces.
}


75. Sort Colors(sort 3 categories)(real question)(interesting)(akamai)
[easy-medium] two passed, counting each category and overwrite. (counting sort) two passes can also solve 4 colors.
(one pass)three pointers. if 0, swap(i++,left++), if 2, swap(i,right--), else i++; while(i<=right)


151. Reverse Words in a String(real question)(interesting)
[easy-medium] 1. trim().split(" +") to String[]. and reverse it.
2. scan word right to left with one pointer to the end of word, another check if a[i-1] == ' ';
    if(s.charAt(i) == ' ') j = i;
    else if(i==0 || s.charAt(i-1) == ' '){  // i==0 corner case, s.charAt(i-1) very good!!!
        if(sb.length() != 0) sb.append(" ");  // sb.length !=0 corner case.
        sb.append(s.substring(i,j));
    }
follow up: if there is no leading/trailing spaces and each word is separated by one space, do it o(1) space.
reverse[0,n-1]; reverse each word.

344. Reverse String
[easy] two pointers from both end.

345. Reverse Vowels of a String
[easy] two pointers find vowels and swap.

163. MissingRanges(VIP)(real question)(interesting)(return missing interval)(tricky)
[medium] cur-pre >=2, extra two sentinels, pre=start-1; cur = (i==num.length)?end+1; num[i];
public List<String> findMissingRanges(int[] nums, int lower, int upper) {
    List<String> ret = new ArrayList();
    Long pre = (long)lower-1;
    for(int i=0;i<=nums.length;i++){
        long cur = (i == nums.length)?(long)upper+1 : nums[i];
        if(cur - pre >= 2) ret.add(addString((long)pre+1, (long)cur-1));
        pre = cur;
    }
    return ret;
}
public String addString(long from, long to){
    return (from == to)? ""+from : from + "->" + to;
}

392. Is Subsequence
[medium-easy] two pointers. return i == a.length;

475. Heaters
[easy-medium] two pointers or binary search. Math.



---------------------------------------------------
5.Sliding Window(reviewed on 10/27/2016, 11/14/2016, 12/1/2016)
all is compare count with k([0,n]) except N424, use window - maxRepeatingChar compare with k.
---------------------------------------------------
643. Maximum Average Subarray I
[]

674. Longest Continuous Increasing Subsequence
[]



3. Longest Substring Without Repeating Characters(interesting)(real question) abcdf
[medium] BF is o(n^2). windows contains only unique chars. ret = Math.max(ret, i-left+1);
hashtable + sliding window with two pointers. o(n) time,  map(char, index)
map to store index of previous duplicate num[i], update left if found in map.
    for(int i=0; i<s.length();i++){
        if(map[a[i]]++ >= 1) count++;  // >=1   count here means count of repeating chars
        while(count > 0){ // move left pointer one by one
            map[a[left]]--;
            if(map[a[left]] >= 2) count--;  // >=2
            left++;
        }
        ret = Math.max(ret, i-left+1);
    }

159. Longest Substring Which Contains at most 2 Unique Characters(VIP)(interesting) aaabbb
340. Longest Substring Which Contains at most k Unique Characters(VIP)(interesting)(real question)(Facebook)
[hard-medium] windows contains only unique k chars. ret = Math.max(ret, i-left+1);
sliding window with k size. use help of hashmap<char, count> or int[256] to move window.
    for(int i=0; i<str.length; i++){
        if(map[str[i]]++ == 0) count++;  // ==0  count here means count of unique chars
        while(count>k){
            map[str[left]]--;
            if(map[str[left]]==0) count--; // ==0
            left++;
        }
        ret = Math.max(ret, i-left+1);  //windows only contains at most k unique chars.
    }

424. Longest Repeating Character Replacement(real question)(google)(tricky to move window)[to think more]
[medium-hard] find largest window size == MaxCharCount + k, fix window size, increase it once found more maxCharCount
for(int i=0;i<a.length;i++){
    maxRepeatChar = Math.max(maxRepeatChar,  ++map[a[i]]); // add window
    while(i-left+1 - maxRepeatChar > k) { // move window when (window_length - count > k)
        map[a[left]]--;
        left++;
    }
    ret = Math.max(ret, i-left+1);  //update ret to window size
}

76. Minimum Window Substring(given two strings s and t, find minimum window in s contains t.)(interesting)
[hard-medium] sliding window.
    int[] map = new int[128];
    for(char c: t.toCharArray()) map[c]++;
    int left=0, right=0, count=t.length(), start=0, len= Integer.MAX_VALUE;
    char[] a = s.toCharArray();
    while(right< s.length()){
        if(map[a[right++]]-- >= 1) count--;  // >=1
        while(count == 0){ // downsizing window
            if(right-left < len){
                len = right - left;
                start = left;
            }
            if(map[a[left++]]++ >=0) count++; // >=0
        }
    }
    return (len == Integer.MAX_VALUE)? "": s.substring(start, start+len);

438. Find All Anagrams in a String(interesting)
[easy-medium] a window of size p. similar to N76.
    int[] map = new int[128];
    for(char c: p.toCharArray())map[c]++;

    int left=0, right=0, count=p.length();
    char[] a = s.toCharArray();
    while(right<s.length()){
        if(map[a[right++]]-- > 0) count--;
        if(count == 0) ret.add(left);
        if(right-left == p.length() && map[a[left++]]++>=0) count++;
    }
    return ret;


209. Minimum Size Subarray Sum(interesting)
[medium-easy] sliding window. not need of count, easy.
    int front=0, min = Integer.MAX_VALUE, sum=0;
    for(int i=0;i<nums.length;i++){
        sum += nums[i];
        if(sum>=s) {
            //advance front
            while(sum-nums[front] >=s){
                sum -= nums[front];
                front++;
            }
            min = Math.min(min, i-front+1); //update min
        }
    }
    return min == Integer.MAX_VALUE ? 0 : min;


487. Max Consecutive Ones II
[medium]


---------------------------------------------------
6.Sort(reviewed on 10/10/2016, 12/1/2016)
---------------------------------------------------
179. Largest Number(given [3, 30, 34, 5, 9], the largest formed number is 9534330.)
[medium] custom sort base on String desc (330 before 303)
Collections.sort(list, (a, b)-> (""+b+a).compareTo(""+a+b));

215. Kth Largest Element in an Array
[medium] quickselect, time o(n) = n + n/2 + n/4 .., space o(1), compare quicksort with quickselect
heap, time o(nlogk), space o(k)

PriorityQueue<Integer> heap = new PriorityQueue<Integer>(k);
for(int e : nums){
    if(heap.size()<k) heap.add(e);
    else{
        if(e > heap.peek()) {
            heap.poll();
            heap.add(e);
        }
    }
}
return heap.poll();


296. Best Meeting Point(A group of two or more people wants to meet and minimize the total travel distance)
[medium] sort and median will produce the total shortest distance.

327. Count of Range Sum
[medium] merge sort.

406. Queue Reconstruction by Height(interesting)(tricky)
[medium] sort + insertion.sort descending by height and ascending of rank
Arrays.sort(people, (a,b) -> a[0] == b[0]? a[1]-b[1] : b[0]-a[0]);// sort height reversely, and rank
List<int[]> ret = new LinkedList();
for(int[] p : people){
    ret.add(p[1], p);//insert people to its position by rank
}
return ret.toArray(new int[people.length][]);

493. Reverse Pairs
[medium] merge sort

539. Minimum Time Difference
[]

581. Shortest Unsorted Continuous Subarray
[] sort




---------------------------------------------------
7.Binary search(reviewed on 9/28/2016, 10/27/2016, 12/1/2016, 9/5/2017)
(
1. regular BS is while(left<=right), and has early return
2. special case like find min in rotated array, while(left<right) return nums[left]; compare with right
3. special case like two recursion call in == condition to find index range of target
4. special case to store middle result ret while recurse, like N69.sqrt and N278.badVersion
)
---------------------------------------------------
540. Single Element in a Sorted Array
[]

644. Maximum Average Subarray II
[]

668. Kth largest Number in Multiplication Table
[]


33. Search in Rotated Sorted Array
[hard-medium] 4 if conditions, compare num[mid] with num[left],
further compare target to num[left] and num[mid].

81. Search in Rotated Sorted Array II (duplicate in array)
[hard-medium] similar to 33, left++ if num[left] = num[mid]. worst case o(n)

153. Find Minimum in Rotated Sorted Array(real question)
[easy-medium]  [only exception of left<right rather than left<=right], because it's return num[left]
if(num[mid]< num[r]) r= mid(not mid-1, because it can be the min);
else l = mid+1; return num[l]  while(l<r)

154. Find Minimum in Rotated Sorted Array II(duplicate is allowed)(real question)
[hard-medium] if(num[mid] == num[r]) r--;  else are the same as 153.

*34. Search for a Range(interesting)(can only do recursion, because there are two recursive call in == condition)
[medium] more code when ==; update ret[0] and ret[1]; two direction recursion dfs(start, mid-1); dfs(mid+1,end)
    public void binarySearch(int[] nums, int target, int start, int end, int[] ret){
        if(start<=end){
            int mid = (end - start)/2 + start;
            if(nums[mid] == target){
                if(mid < ret[0] || ret[0] == -1) ret[0] = mid;
                if(ret[1] < mid || ret[1] == -1) ret[1] = mid;

                binarySearch(nums, target, start, mid-1, ret);
                binarySearch(nums, target, mid+1, end, ret);
            }else if (nums[mid] < target){
                binarySearch(nums, target, mid+1, end, ret);
            }else binarySearch(nums, target, start, mid-1, ret);
        }
    }


Real Question: given an sorted array, find all numbers which count of it larger than n/4.
1. at most there are 3 such numbers, if exist, they should be at n/4, 2n/4, 3n/4.
2. binary search on those 3 or 2 numbers, find first and last index of them, if length larger than n/4, then it qualifies.(N34)
    1 2 3 4 5 6 7 8
        |     |

    1 2 3 4 5 6 7
      |   |   |


35. Search Insert Position(real question)
[medium-easy] regular binary search, insertion position is the left bound; return left;

50. Pow(x, n) (real question)(interesting)
[medium] binary search.
if(n==0) return 1;
if(n<0) return 1/pow(x, -n); // if n = Int.MIN_VALUE, will overflow. then, 1/x*pow(x,-(n+1))
int ret = pow(x, n/2);
if(n%2==0) return ret*ret;
else return ret*ret*x;

69. Sqrt(x) (interesting)
[easy-medium] negative can't be sqrt. regular BS, but store temp ret in condition. use long to handle overflow.
int left=1, right=x, ret=1;
while(left<=right){
    int mid = (right-left)/2 + left;
    int tmp = (long) mid*mid;
    if( tmp== x) return mid;
    else if(tmp < x) {ret = mid; left=mid+1;}
    else right = mid-1;
}
return ret;


74. Search a 2D Matrix(can be converted to 1D row by row.)
[easy-medium] l=0, r=row*col-1; midVal = matrix[mid/col][mid%col],  time o(log(m+n))

240. Search a 2D Matrix II(sorted by rows and cols)
[easy-medium] o(m+n). start on top right point, row=0, col=col_size-1; row++ or col--;
time can also be o(mlogn) or o(nlogm)

162. Find Peak Element (tricky but interesting)
[medium] If the middle element is smaller than the its left neighbor, then there is always a peak in left half
    while(left<= right){
        int mid = (right-left)/2 + left;
        if( (mid==0 || nums[mid] > nums[mid-1]) &&
                (mid == nums.length-1 || nums[mid] > nums[mid+1])){
            return mid;
        }
        else if(mid>0 && nums[mid] < nums[mid-1]) right = mid-1;
        else left = mid+1;
    }

278. First Bad Version(real question)
[easy] if (mid is isBad){ret = mid; r =mid-1}; else l=mid+1;

302. Smallest Rectangle Enclosing Black Pixels
[medium-hard]

374. Guess Number Higher or Lower
[easy] regular binary search.

483. Smallest Good Base
[medium]


---------------------------------------------------
8.Greedy(reviewed on 12/19/2016, 9/7/2017)
---------------------------------------------------
605. Can Place Flowers
[]


53.	Maximum Subarray(Find the contiguous subarray which has the largest sum)
[easy] localMax = max(n, n + localMax); globalMax = max(globalMax, localMax)

55. Jump Game(each num means the longest distance you can jump, can you reach the end?)
[easy] o(n). store max_jump and compare with end index.

45. Jump Game II(return min jumps to end, assume there is a solution)(interesting)
[hard-medium] greedy. store max_jump and cur_jump.
int ret=0, last_jump_max=0, cur_jump_max=0;
for(int i=0;i<nums.length-1;i++){
    cur_jump_max = Math.max(cur_jump_max, i+nums[i]);
    if(i == last_jump_max){
        ret++;
        last_jump_max =cur_jump_max;
    }
}
return ret;

134. Gas Station(N gas stations along a circular route, cost[], gas[], return start point can circle around)
[easy-medium] greedy. read problem description carefully, because guaranteed solution
to be unique if failed at i, we can give up all index [0,i], start checking from i+1.
reset current_sum to 0 if <0 and start=i+1; overall_sum should also >0;
    int net_sum=0, cur_sum=0, start=0;
    for(int i=0;i<gas.length;i++){
        cur_sum += gas[i] - cost[i];
        net_sum += gas[i] - cost[i];
        if(cur_sum < 0) {
            start = i+1;
            cur_sum = 0;
        }
    }
    if(net_sum < 0) return -1;
    return start;


277. Find the Celebrity(celebrity means everyone know it and it does not know anyone)
[medium]

330. Patching Array
[medium] greedy.


418. Sentence Screen Fitting
[medium] greedy.


455. Assign Cookies(return max children can be satisfied with their greedy factor)
[easy] sort, greedy. count++ when size of cookie >= child's greed.
    Arrays.sort(g); //g is children's greedy factor
    Arrays.sort(s); //s is number of cookie
    int i=0;
    for(int j=0;j<s.length && i<g.length; j++){
        if(g[i] <= s[j]) i++;
    }
    return i;



---------------------------------------------------
9.DP(reviewed on 10/2/2016)
---------------------------------------------------
552. Student Attendance Record 2
[hard]

562. Longest Line of Consecutive One in Matrix
[medium] DP

568. Maximum Vacation Days
[]

600. Non negative Integers without Consecutive Ones
[]

629. K Inverse Pairs Array
[] DP


639. Decode Ways II
[hard]


646. Maximum Length of Pair Chain
[]

664. Strange Printer
[] similar to N546 Remove Boxes?

673. Number of Longest Increasing Subsequence
[]


62. Unique Paths(matrix, can only move down and right, return max unique path)(real question)
[easy] dp[i][j] = dp[i-1][j] + dp[i][j-1];

63. Unique Paths II(with obstacles marked as 1)(real question)
[easy-medium] rolling array.
if(obstacleGrid[i][j] == 1) dp[j] = 0;
else if(j>0) dp[j] += dp[j-1];  //(j>0) important

64. Minimum Path Sum(matrix, can only move down and right, return min path sum)
[easy]  dp[j] = min(dp[j-1], dp[j]) + grid[i][j].  similar to 62, but use rolling array(o(m) space).

70. climb stairs. (either 1 step or 2 steps, return distinct ways to the top)(real question)
[easy-medium]   dp[i] = dp[i-2] + dp[i-1].
this is kind of fibonacci, so can be: a=b=1; i in [2,n]{c= a+b, a=b, b=c;} return b;

91. Decode Ways('A'->1, ... 'Z'->26, return how many ways to decode a given string)
[medium] hard on how to analyze this problem. f(n) = f(n-1) + f(n-2) if valid in [1,26]
dp[0]=dp[1]=1;
if(isValid(s.substring(i-1, i))) dp[i] += dp[i-1];
if(isValid(s.substring(i-2, i))) dp[i] += dp[i-2];

120. Triangle(minimum path sum from top to bottom, move down only adjacent)[important]
[medium] (Bottom up DP!!!) rolling array. dp[i] = min(dp[i], dp[i+1]) + matrix[i][j]

121. Best Time to Buy and Sell Stock(at most one transaction)(Amazon)
[easy-medium] greedy. store global min, and update max each time.
minVal = min(minVal, a[i]);  ret = max(ret, a[i]-minVal);
[medium] return index rather than maxProfit
for(int i=1;i<prices.length;i++){
    if(min > prices[i]){
        min = prices[i];
        possible_min_index = i;
    }
    if(max < prices[i] - min){
        ret[0] = possible_min_index;
        ret[1] = i;
        max = prices[i] - min;
    }
}


122. Best Time to Buy and Sell Stock II(could buy and sell as much as possible.)
[easy-medium] greedy. add up all the positive difference between two days.

123. Best Time to Buy and Sell Stock III(at most 2 transaction)(interesting)
[hard-medium] two passes DP. divide and conquer.
find max profit <= i and max profit >= i. combine them ret = max(ret, left[i]+right[i])

188. Best Time to Buy and Sell Stock IV(allow at most k transaction)
[hard] two array DP. [TODO]

309. Best Time to Buy and Sell Stock with Cooldown
[medium-hard] not sure. [TODO]

139. Word Break(check if string can be segmented into a few words in a given dictionary)
[medium-hard] DFS will TLE.  similar to N132. Palindrome Partitioning II
dp[0]=true; for each substring, if (dp[j]==true && word.contains(s.substring[j,i+1)) dp[i+1] = true;

140. Word Break II(add spaces in str to construct a sentence, return all possible results.)
[hard]  DP + DFS + backtracking. need a ArrayList<String>[] preWordsList;
store each dictionary word in preWordsList, add to ret by backtracking with matching str length.

53	Maximum Subarray(max continuous subarray)(real question)
[easy] local_max = Math.max(local_max+num, num);  ret = Math.max(ret, local_max);

152. Maximum Product Subarray(return the largest product in a contiguous subarray)(interesting)(real question)
[medium] DP or greedy.  need cur_max and cur_min.
    int tmp = cur_max;
    cur_max = Math.max(nums[i], Math.max(cur_max*nums[i], cur_min*nums[i]));
    cur_min = Math.min(nums[i], Math.min(tmp*nums[i], cur_min*nums[i]));
    max = Math.max(max, cur_max);

198. House Robber(return maximum money can rob but not adjacent houses.)(real question)
[easy] dp[i] = max(dp[i-i], dp[i-2] + num[i]).
or greedy, use even and odd. even=max(even,odd); odd=max(even,odd);

213. House Robber II(house in a circle)(real question)
[medium] two passes of DP, 1. remove head.  2. remove tail.

337. House Robber III(binary tree, very interesting)
[medium-hard] DFS + DP(hashtable).  int = DFS(node, map), naive is not using map.
public int rob(TreeNode root, HashMap<TreeNode, Integer> map) {
    if (root == null) return 0;
    if(map.containsKey(root)) return map.get(root);

    int val = 0;
    if (root.left != null) val += rob(root.left.left, map) + rob(root.left.right, map);
    if (root.right != null) val += rob(root.right.left, map) + rob(root.right.right, map);
    val =Math.max(val + root.val, rob(root.left, map) + rob(root.right,map));
    map.put(root, val);
    return val;
}

204. Count Primes(return number of primes less than n)(interesting)
[easy-medium] dp[i*j] = false
set dp[0,n] =true; if dp[i] IS prime, set dp[i*j] = NOT Prime, while j in[2,i*j<=n]; then count.

279. Perfect Squares(find the least number of perfect square numbers sum to n. 4+9=13)
[medium] similar to N204.  dp[i+j*j] = Math.min(dp[i+j*j], dp[i]+1);
for(int i=0;i<=n;i++){
    for(int j=1;i+j*j<=n;j++){
        dp[i+j*j] = Math.min(dp[i+j*j], dp[i]+1);
    }
}

322. Coin Change(return fewest number of coins sum to a val)(real question)
[medium] similar to N279.  dp[i+j] = min(dp[i+j], dp[i]+1)
int[] dp = new int[amount+1];
for(int i=1;i<=amount;i++) dp[i] = Integer.MAX_VALUE;
for(int i=0;i<amount;i++){
    for(int coin: coins){
        if(i+coin <= amount && dp[i] != Integer.MAX_VALUE)
            dp[i+coin] = Math.min(dp[i+coin], dp[i]+1);
    }
}
return dp[amount] == Integer.MAX_VALUE? -1 : dp[amount];

221. Maximal Square(matrix with 0 and 1, find largest square with all 1 and return its area.)
[medium] if matrix[i][j] == '1':  dp[i][j] = 1 + min(dp[i-1][j-1], dp[i-1][j], dp[i][j-1])
(time o(m*n), space(m*n), space can be reduced use rolling array and one variable)

256. Paint House(Find the minimum cost to paint all houses, no two adjacent houses have the same color)
[medium]

265. Paint House II
[medium]

276. Paint Fence(Return number of ways to paint fence that no more than two adjacent fence have the same color, k colors)
[medium]

300. Longest Increasing Subsequence(return max length of increasing subsequence in array)(interesting)
[medium] dp[i] = Math.max(dp[i], dp[j]+1)
for(int i=0;i<nums.length;i++){
    dp[i] = 1;
    for(int j=0;j<i;j++){
        if(nums[j] < nums[i]) dp[i] = Math.max(dp[i], dp[j]+1);
    }
    max = Math.max(max, dp[i]);
}

303. Range Sum Query - Immutable(find the sum of the elements between indices [i,j])
[easy] sum(i) = sum[0,i); return sum(j+1)-sum(i);
sum = new int[nums.length + 1];
for (int i = 0; i < nums.length; i++) {
    sum[i + 1] = sum[i] + nums[i];
}

304. Range Sum Query 2D - Immutable
[easy-medium] similar N303, but in matrix, sum by row and add each row.

338. Counting Bits(return number of 1 bits in range[0,n])(very interesting)
[medium] DP + bit. ret[i] = ret[i>>1] + (i&1)  for i in [1,num]

368. Largest Divisible Subset(find largest set each si%sj==0)(interesting)
[medium-hard] DP+backtracking. [TODO]

375. Guess Number Higher or Lower II
[medium] 2d DP. [TODO]

376. Wiggle Subsequence(return length of longest wiggle subsequence)(interesting) [TODO]
[medium] alternate DP. if(num[i]>num[i-1])p=q+1; else if(num[i]<num[i-1])q=p+1; return max(p,q);

416. Partition Equal Subset Sum
[medium] find half sum of array and DP.


446. Arithmetic Slices II Subsequence
[hard] DP.


466. Count The Repetitions
[hard] DP


471. Encode String with Shortest Length
[hard] DP

472. Concatenated Words
[medium] DP

474. Ones and Zeroes
[medium] DP

514. Freedom Trail
[hard] DP


516. Longest Palindromic Subsequence
[hard] DP

518. Coin Change 2
[medium] DP

583. Delete Operation for Two Strings(equivalent to Longest Common SubSequence (LCS))
[medium] dp[i][j] = (word1.charAt(i-1) == word2.charAt(j-1)) ? 1 + dp[i-1][j-1] : Math.max(dp[i-1][j], dp[i][j-1]);



---------------------------------------------------
10.Random(reviewed on 10/27/2016, 12/1/2016, 9/7/2017)
---------------------------------------------------
382. Linked List Random Node
[medium] save list to array, and call random. o(n) space
follow up: o(1) space, o(n) time. see Reservoir Sampling. update ret when rand.nextInt(++count) == target(most likely 0)
    public int getRandom() {
        int ret=0, i=0;
        ListNode cur = head;
        while(cur != null){
            if(rand.nextInt(++i) == 0) ret = cur.val;
            cur = cur.next;
        }
        return ret;
    }

398. Random Pick Index(an array of integers with duplicates, randomly output the index of a given target number.)
[medium] Reservoir Sampling
    int ret = 0, count=0;
    for(int i=0;i<nums.length;i++){
        if(nums[i] == target){
            int j = rand.nextInt(++count);
            if(j==0) ret = i;
        }
    }
    return ret;

384. Shuffle an Array(shuffle a deck of card)(Amazon)
[medium] Fisher–Yates shuffle.  https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
for(int i=a.length-1; i>=1; i--){
    int j = random.nextInt(i+1);
    swap(a, i, j);
}


---------------------------------------------------
11.Linked List(reviewed on 10/27/2016)(out of box thinking, modify value in node)
---------------------------------------------------
2. Add Two Numbers(real question)
[easy-medium] carry. one list is shorter than the other. extra carry node. similar to N415.

19. Remove Nth Node From End of List
[easy] two pointers, one moves N steps ahead.

21. Merge Two Sorted Lists(real question)
[easy] dummy node.

24. Swap Nodes in Pairs(swap adjacent node)(real question)
[easy-medium] dummy node and odd and even.  need three pointers to swap: pre, cur and nextNode.

206. Reverse Linked List
[easy-medium] iterative one. need pre, cur, next. similar to N24.

92. Reverse Linked List II(from position m to n)
[medium] dummy node to solve first node issue. need extra pre_m, m_node to link head and tail.
pre_m.next = pre, m_node.next=cur.  pre, cur, next for reversing node. m-- >1; n-- >1

61. Rotate List
[easy-medium] just need link tail and head, break one link, reset head node.
count node, tail -> head, move n - k steps, head = tail.next, tail.next = null

83. Remove Duplicates from Sorted List
[easy] skip next if equals. if ==, cur.next=cur.next.next, else cur = cur.next.

82. Remove Duplicates from Sorted List II(only return unique node, remove all nodes exists more than once)
[medium] need dummy node to skip the first one. check next.val == next.next.val
store duplicate value by checking cur.next.val == cur.next.next.val , and skip all duplicate if equals duplicate value.

86. Partition List(move node.val < x to list 1, move node.val >= x to list 2, and link them.)
[medium] two dummy nodes as the start of each list, two p pointers points to current node will end up to the tail of each list.

141. Linked List Cycle
[easy] two pointers, slow and fast. while(fast!=null && fast.next != null) ...

142. Linked List Cycle II(find entrance of cycle)
[medium] once they meet, reset slow to head, and move them at the same pace, they will meet at the entrance.

143. Reorder List (1->2->3->4   ----->    1->4->2->3)
[medium] find mid point, and reverse the second half, and merge them.

147. Insertion Sort List
[medium] need dummy node. for each node insert it to it's proper position.

148. Sort List(interesting)
[medium] merge sort.
if(head==null || head.next==null) return head;
slow = head, fast = head.next.next // important, make sure slow is the node before mid node.
ListNode l1 = sortList(slow.next);
slow.next=null;
ListNode l2 = sortList(head);
return merge(l1, l2);

160. Intersection of Two Linked Lists(interesting)
[easy-medium] subtract the length of two lists. the longer one moves the diff steps first.

203. Remove Linked List Elements
[easy] 1. dummy node to handle first node
2. or while loop to skip the first node.

234. Palindrome Linked List(require o(1) space)
[easy-medium] reverse the first half while find mid point; compare reversed with slow. [TODO not implemented yet]

237. Delete Node in a Linked List (only access to that node.)
[easy] copy node value. remove the next node.

328. Odd Even Linked List
[easy-medium] one pointer for odd, one pointer for even.
while(even!=null && even.next != null) {...}

445. Add Two Numbers II
[medium] with stack



---------------------------------------------------
12.Hashmap(reviewed on 9/29/2016, 10/28/2016, 9/7/2017)
hashmap can be used as count each char/num, or store index of char/num
hashset usually used to check if visited or not.
---------------------------------------------------

49. Group Anagrams(important)(real question)
[medium] hashmap<String, list>  or hashmap<int, list>.
1. Arrays.sort(word.toCharArray()) and String(char[]) as key in map.   o(nlogn) time
2. foreach char[c-'a']++; String(char[]) as key in map.  o(n) time


242. Valid Anagram(is valid anagram of two strings.)
[easy] hashtable or sort string.


If a String Contains an Anagram of Another String
// sliding window + hashmap. similar to N159 N340 and N49
// assume all english chars.
public boolean isContainAnagram(String s, String t){
    int m = s.length(), n = t.length();
    if(m < n) return false; // s should be longer than t
    char[] a= new char[26];
    for(char c: t)a[c - 'a']++;
    String key = new String(a);

    char[] b= new char[26];
    for(int i=0, left=0 ;i<m;i++){
        b[s.charAt(i) - 'a']++;
        if(i>=n-1){
            if(key.equals(new String(b))) return true;
            b[s.charAt(left++) - 'a']--;
        }
    }
    return false;
}


554. Brick Wall
[]

560. Subarray Sum Equals K
[]map + preSum

567. Permutation in String
[] map + window

594. Longest Harmonious Subsequence
[]

599. Minimum Index Sum of Two Lists
[] map

609. Find Duplicate File in System
[] map

621. Task Scheduler
[] map

633. Sum of Square Numbers
[]

1. Two Sum(real question)(interesting)
[easy] store (sum-num[i]) and index in hashtable.  map(sum-num[i], index)
throw new IllegalArgumentException("No solution");

36. Valid Sudoku
[easy-medium] hashset to check if visited.

166. Fraction to Recurring Decimal
[medium] map<long, index>
map.put(remainder, sb.length()), sb.insert(map.get(remainder), "("); return sb.toString().replace("(0)","")

187. Repeated DNA Sequences(find all repeated 10-length string)
[easy] map<str, count> with window length == 10

202. Happy Number(recursion on sum of each digit^2)
[easy] hashset<int> to store visited number

205. Isomorphic Strings(Two strings are isomorphic if the characters in s can be replaced to get t.)case: aa and ab.
[easy-medium] two way hashmaps. return func(s,t) && func(t,s);

290. Word Pattern
[easy-medium] two way hashmaps, the same as N205.   map(char, String) and map(String, char)

217. Contains Duplicate(if duplicate integer exist in an array.)
[easy] hashset.

219. Contains Duplicate II(duplicate within k distance)
[easy] hashtable, value and idnex. check distance.  map<num, index>

220. Contains Duplicate III(tricky)
[medium-hard]  treeset, treeSet.subSet(lowerKey(inclusive), higherKey(exclusive))
    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        if(nums == null || nums.length <= 1 || k<0 || t<0) return false;
        TreeSet<Long> treeSet = new TreeSet<>();
        for(int i=0;i<nums.length;i++){
            // check if difference of nums[i] and nums[j] is <= t
            if(treeSet.subSet((long)nums[i]-t, (long)nums[i]+t+1).size() > 0) return true; // can't reverse sequence

            treeSet.add((long)nums[i]);
            if(i>=k) treeSet.remove((long)nums[i-k]); // maintain the window size k
        }
        return false;
    }

249. Group Shifted Strings
[medium] map<key_string, list_of_string> hash each string to a key.
offset = s.charAt(0) - 'a'; for(int i=0;i<s.length();i++)sb.append((s.charAt(i) - offset + 26) % 26 + 'a');]


288. Unique Word Abbreviation
[medium] If this word (also this word’s abbreviation)is not in the dictionary
OR this word and only it’s abbreviation in the dictionary. We call a word’s abbreviation unique.


299. Bulls and Cows(both index and val match is bull, val match is cow)
[medium] need a counter int[] for each number.
    public String getHint(String secret, String guess) {
        int num_bull=0, num_cow=0;
        int[] nums = new int[10];
        for(int i=0;i<secret.length();i++){
            if(secret.charAt(i) == guess.charAt(i)) num_bull++;
            else{
                if(nums[secret.charAt(i)-'0']++ < 0) num_cow++;
                if(nums[guess.charAt(i)-'0']--  > 0) num_cow++;
            }
        }
        return num_bull+"A"+num_cow+"B";
    }

318. Maximum Product of Word Lengths(two words don't share chars)(interesting)
[medium] 1. hashset to store chars for each word. time o(n^2), space(26*n)
2. optimize, store each char in an int[] as bit, do "&" for each int. time o(n^2), space(n)
bit, 1<<n(move 1 to left by n position),
use each bit of int to represent 26 lower-case char. for(char c: chars) map[i] |= 1 << (c - 'a');

325. Maximum Size Subarray Sum Equals k
[medium] map + preSum


347. Top K Frequent Elements(interesting)(real question)(google)
[medium] bucket sort o(n) time but o(n) space: map(count, num). List[] buckets= new List[num.length+1];
heap o(nlogn) time, but o(k) space.

356. Line Reflection
[medium]


451. Sort Characters By Frequency(google, amazon)
[medium] counting/bucket sort.  o(n).
counting sort + map<count, list_of_char>, list max-min by going through len in [n-0] of map

349. Intersection of Two Arrays
[easy] one hashset<val> for fast lookup.

350. Intersection of Two Arrays II(return duplicate as well)
[easy] one hashmap<int, count>.

383. Ransom Note(if "A" can be constructed from "B")(real question)
[easy] hashtable, count and compare each char.

387. First Unique Character in a String
[easy-medium] two pass. map(char, count).  return the first count==1 foreach char in str(not map).

388.Longest Absolute File Path
[medium] hashtable to store last level length(will be replaced by new line).
process line by line using s.split("\n"); "\t" is counted as one char.
    public int lengthLongestPath(String input) {
        String[] paths = input.split("\n");
        int[] stack = new int[paths.length+1];
        int maxLen = 0;
        for(String s:paths){
            int lev = s.lastIndexOf("\t")+1, curLen = stack[lev+1] = stack[lev]+s.length()-lev+1;
            if(s.contains(".")) maxLen = Math.max(maxLen, curLen-1);
        }
        return maxLen;
    }

389. Find the Difference(find one different char in two strings)
[easy] two pass. 1st: map(char, count)  2ed: count--; return if count<0;

403. Frog Jump
[medium] map.

447. Number of Boomerangs(find all three points(a,b,c) which dist(a,b) == dist(b,c))
[easy-medium] hashmap to store previous distance, ret += pre_dist*2; map.put(dist, pre_dist+1);
use map<distance,count> in first loop, to reduce from o(n^3) to o(n^2)


454. 4Sum II(given 4 lists, compute how many tuples A[i] + B[j] + C[k] + D[l] is zero)(interesting)
[medium] hashmap on(C[i] + D[j]), check if exist in map (-1*(A[i]+B[j])). time o(n^2), BF is(n^4)


500. Keyboard Row
[medium] map.

523. Continuous Subarray Sum
[medium] map + preSum

525. Contiguous Array
[medium] map + preSum

527. Word Abbreviation
[hard]

531. Lonely Pixel I
[medium]

533. Lonely Pixel II
[medium]

532. K diff Pairs in an Array
[medium] map


---------------------------------------------------
13.Stack/Queue(reviewed on 9/29/2016, 10/27/2016, 9/7/2017)
---------------------------------------------------
636. Exclusive Time of Functions
[]

649. Dota2 Senate
[] 2 queues.


20. Valid Parentheses(real question)
[easy] push if it's opening parenthesis like "({[", else stack.pop, return false if not matched closing parenthesis.")}]"

71. Simplify Path
[medium] pop if it's "..", continue if it's '.', else push

84. Largest Rectangle in Histogram(return max area of an array represented histogram)(interesting.)
[hard] stack<index_of_array>, maintain the top of stack is the max value.
o(n) time.
while(i<length){
    if(stack is empty || incoming >= stack.top)push and i++;
    else pop and updateMax(keep updating until empty or larger than top);
}
while(stack is not empty) updateMax;

public int getIMax(int[] heights, Stack<Integer> s, int i, int max){
    int height = heights[s.pop()];
    int length = s.isEmpty() ? i : i - 1 - s.peek();
    return Math.max(max, height*length);
}
BF o(n^2), for each i, get area from left and right, left-- or right++ until a[i] > a[left] or a[right].


150. Evaluate Reverse Polish Notation(real question)
[easy] if operand, pop twice and evaluate and push back, else push.

155. Min Stack(interesting)(real question)(can easily extended to max or both)
[easy-medium] two stacks. stack, minStack.
push to minstack only when it's empty or incoming is <=(equal to handle duplicate) than minStack.top();
pop minStack only when val = top.
used the trick of stack's top always be the smallest until a smaller comes after.

225. Implement Stack using Queues(real question)
[easy-medium]
1 queue cyclic operations. o(1) push, o(n) top and pop
2 queues, 1 queue to store reversed items, another one help to make it happen. o(n) push, o(1) top and pop.
stored reversed element on q1: push new element to front of q2, add all q1 to q2 and copied p2 back to q1

232. Implement Queue using Stacks(real question)
[easy-medium] two stacks to mimic queue.


224. Basic Calculator(evaluate a simple expression string, "(1+(4+5+2)-3)+(6+8)" = 23)
[hard] stack<int>, store sign as 1 and -1, when '(', push ret and sign, when ')' ret = ret*stack.pop() + stack.pop()
    public int calculate(String s) {
        int ret = 0, sign =1;
        Stack<Integer> stack = new Stack<>();
        for(int i=0;i<s.length();i++){
            if(Character.isDigit(s.charAt(i))){
                int sum = s.charAt(i) - '0';
                while(i+1 < s.length() && Character.isDigit(s.charAt(i+1))){
                    sum = sum*10 + s.charAt(i+1) - '0';
                    i++;
                }
                ret += sum*sign;
            }
            else if(s.charAt(i) == '+') sign = 1;
            else if(s.charAt(i) == '-') sign = -1;
            else if(s.charAt(i) == '('){
                stack.push(ret);
                stack.push(sign);
                sign = 1;
                ret = 0;
            }
            else if(s.charAt(i) == ')') ret = ret * stack.pop() + stack.pop();
        }
        return ret;
    }

227. Basic Calculator II(evaluate a string, contains only non-negative integers, +, -, *, /  empty spaces)
[medium] stack<int>
    public int calculate(String s) {
        if(s == null || s.length() ==0) return 0;
        int ret = 0, num = 0;
        char sign = '+';
        Stack<Integer> stack = new Stack<>();
        for(int i=0;i<s.length();i++){
            if(Character.isDigit(s.charAt(i)))  num = num*10 + s.charAt(i) - '0';
            if(!Character.isDigit(s.charAt(i)) && s.charAt(i) != ' ' || i == s.length()-1){
                if(sign == '+') stack.push(num);
                else if(sign == '-') stack.push(-num);
                else if(sign == '*') stack.push(stack.pop() * num);
                else if(sign == '/') stack.push(stack.pop() / num);
                sign = s.charAt(i);
                num = 0;
            }
        }
        for(int i:stack) ret+= i;
        return ret;
    }



402. Remove K Digits(so that the new number is the smallest)(impressive idea) example: 12345, 54321, 100234, 500432
[medium-hard] stack<int>, pop() if incoming is smaller than stack.peek(), remove leading zeros.
    public String removeKdigits(String num, int k) {
        if(k==num.length()) return "0";
        Stack<Character> stack = new Stack();
        char[] a = num.toCharArray();

        for(int i=0;i<num.length();i++){
            while(k> 0 && !stack.isEmpty() && stack.peek() > a[i]){   // remove larger number in stack
                stack.pop();
                k--;
            }
            stack.push(a[i]);
        }
        while(k-->0) stack.pop();  // case like "1111"  or "12345"

        // construct ret reversely
        StringBuilder ret = new StringBuilder();
        while(!stack.isEmpty()) ret.insert(0,stack.pop());

        while(ret.length() >1 && ret.charAt(0) == '0') ret.deleteCharAt(0); // remove leading zeros
        return ret.toString();
    }


439. Ternary Expression Parser
[medium] stack.


*456. 132 Pattern(find if exist i < j < k and ai < ak < aj.)
[medium] stack solution is not trivia. BF(n^2) is acceptable.
    public boolean find132pattern(int[] nums) {
        int min_i = Integer.MAX_VALUE;
        for (int j = 0; j < nums.length - 1; j++) {
            min_i = Math.min(min_i, nums[j]);
            for (int k = j + 1; k < nums.length; k++) {
                if (nums[k] < nums[j] && min_i < nums[k])
                    return true;
            }
        }
        return false;
    }


496. Next Greater Element 1
[medium]

503. Next Greater Element 2
[medium]


---------------------------------------------------
14.Heap
---------------------------------------------------
218. The Skyline Problem
[hard] heap<height> descending,
visit all points sorted by x, break tie by height(left height is negative),
heap store global height in reversed order, add left height,
remove end height if cur height is diff than previous, add to ret

358. Rearrange String k Distance Apart
[hard]

407. Trapping Rain Water II
[medium]

502. IPO
[medium] two heaps

630. Course Schedule III
[]

632. Smallest Range
[]


659. Split Array into Consecutive Subsequences
[]


---------------------------------------------------
15.Interval(reviewed on 10/27/2016)
---------------------------------------------------
56. Merge Intervals
[hard-medium] sort. Collections.sort(intervals, (Interval a, Interval b)-> a.start - b.start);
two pointers, start and end. if end < next.start; add to interval(start,end) to list; update start and end;
else if end < next.end; end = next.end;   // else when end > next.end do nothing

57. Insert Interval
[hard-medium] insert new interval to sorted list and use solution from N56 to merge.

252. Meeting Rooms(VIP)(detect if there is intersect of interval)
[easy] return false if interval[i].start < interval[i-1].end

253. Meeting Rooms II(VIP)(interesting)
[medium] using heap sorted by interval.end to merge adjacent intervals greedily.
return heap.size();

435. Non-overlapping Intervals
[medium] similar to N452. keep track of end, remove larger end.

452. Minimum Number of Arrows to Burst Balloons(interesting)
[medium] similar to N435. keep track of end point, compare it with next start point.

436. Find Right Interval(interesting)
[medium] BF is o(n^2).
treemap to sort key(interval.start), value=index. cellingEntry(key) to do binary search. o(nlogn)



---------------------------------------------------
16.Binary Tree(reviewed on 9/30/2016, 10/28/2016, 9/5/2017)
---------------------------------------------------
536. Construct Binary Tree from String
[medium]

543. Diameter of Binary Tree
[]

545. Boundary of Binary Tree
[]

549. Binary Tree Longest Consecutive Sequence II
[]

563. Binary Tree Tilt
[]

572. Subtree of Another Tree
[]

606. Construct String from Binary Tree
[]

617. Merge Two Binary Trees
[]

637. Average of Levels in Binary Tree
[] level order

652. Find Duplicate Subtrees
[]

654. Maximum Binary Tree
[]

655. Print Binary Tree
[]

662. Maximum Width of Binary Tree
[] level order.

663. Equal Tree Partition
[]

666. Path Sum IV
[]

671. Second Minimum Node In a Binary Tree
[]




94. Binary Tree Inorder Traversal
[easy-medium] left-root-right. iterative, use stack.
push p to stack if p is not null then p=p.left,  else if p==null, store stack.pop().val,
then p = p.right. while(p!=null || !s.isEmpty)

144. Binary Tree Preorder Traversal
[medium] iteratively. [TODO]

145. Binary Tree Postorder Traversal
[hard] iteratively.  [TODO]

100. Same Tree
[easy] boolean = DFS(node1, node2)
return true if p == null && q==null, false if p==null || q==null; if p.val == q.val
return dfs(p.left, q.left) && dfs(p.right, q.right) else return false

101. Symmetric Tree
[easy-medium] DFS or BFS. similar to N100.
DFS compare left.val == right.val && dfs(left.left, right.right) && dfs(left.right, right.left).
BFS, two queues, lq.push(left,right), rq.push(right,left).

102. Binary Tree Level Order Traversal
[easy] BFS use queue, store size of each level. DFS solution passes level as argument.

107. Binary Tree Level Order Traversal II (return bottom up result)
[easy] almost the same as 102, just change ret.add(list) to ret.add(0,list);

103. Binary Tree Zigzag Level Order Traversal
[medium] 1. could reverse odd number of list with 102 solution. Collections.reverse(res.get(i));
2. use two stacks.

116. Populating Next Right Pointers in Each Node(perfect binary tree)
117. Populating Next Right Pointers in Each Node II(any binary tree)
[medium] use BFS level order traversal solution.
One extra line of: if(i<size-1) node.next = q.peek(); (linking the next node if not the last.)

199. Binary Tree Right Side View
[easy] BFS, level order traversal from right to left.

104. Maximum Depth of Binary Tree(real question)(max of max)
[easy] int = DFS(node)  bottom-up DFS.
    if (root == null) return 0;
    return 1+ Math.max(maxDepth(root.left), maxDepth(root.right));

111. Minimum Depth of Binary Tree(real question)(min of min, if one child is null then max of min)
[easy-medium] int = DFS(node)(one more case than 104 max depth.)  bottom-up DFS.
    if(root == null) return 0;
    if(root.left ==null) return 1 + minDepth(root.right);
    else if(root.right ==null) return 1 + minDepth(root.left);
    else return 1 + Math.min(minDepth(root.left),  minDepth(root.right));
BFS solution works well for highly unbalanced tree.

*110. Balanced Binary Tree(height-balanced tree: every node's subtree diff <= 1)(real question)(interesting)
[easy-medium] BF o(n^2), for each node, check left and right diff. bottom-up DFS.
bottom-up DFS. similar to N104 max depth of binary tree.
    public int dfs(TreeNode root){
        if(root == null) return 0;

        int left = dfs(root.left);
        if(left == -1) return -1;

        int right = dfs(root.right);
        if(right ==-1 || Math.abs(left-right) > 1) return -1;

        return 1+ Math.max(left, right);
    }

    public boolean isBalanced(TreeNode root) {
        return dfs(root) != -1;
    }

*124. Binary Tree Maximum Path Sum(find max sum from any node to any node, not need to across root)(very interesting)
[hard-medium] DFS bottom up, partial max, and global max. int = DFS(node) bottom-up DFS.
int global_max=Integer.MIN_VALUE;
int DFS(node){
    if(node == null) return 0;
    int left_sum = DFS(node.left);
    int right_sum = DFS(node.right);
    int partial_sum = Math.max(node.val, Math.max(node.val + left_sum,  node.val + right_sum));
    global_max = Math.max(global_max,  Math.max(partial_sum, node.val+left_sum+right_sum));
    return partial_sum;
}


105. Construct Binary Tree from Preorder and Inorder Traversal
[medium]dfs(int[] preoder, int preorder_start, int preorder_end, int[] inorder, int inorder_start, inorder_end)
if(preorder_start>preorder_end) return null,
if (preorder_start==preorder_end) return new TreeNode(preorder[preorder_start]);
else build it and recursive on left and right.

106. Construct Binary Tree from Inorder and Postorder Traversal
[medium] DFS. similar to 105.

112. Path Sum(return if sum of any root to leaf path == val)
[easy-medium] boolean = DFS(node, val)
if(root == null) return false;
if(root.val == sum && root.left ==null && root.right == null) return true;
return dfs(root.left, sum-root.val) || dfs(root.right, sum-root.val)

113. Path Sum II(return all path == val)
[medium] DFS + backtracking.  void = dfs(node, val, ret, list)
pass along ret and cur_list. return condition is the same as 112.
cur_list.add(root.val); dfs(ret, root.left, cur_list, sum-root.val); cur_list.remove(root.val)
 ... the same goes for right node.

437. Path Sum III(find count of path sum to a target, can start from any node, but only downwards.)
[easy-medium] return dfs(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);
public int pathSum(TreeNode root, int sum) {
    if(root == null) return 0;
    return dfs(root, sum) + pathSum(root.left,sum) + pathSum(root.right,sum);
}
public int dfs(TreeNode node, int sum){
    if(node == null) return 0;
    return (node.val == sum ? 1 : 0) + dfs(node.left, sum-node.val) + dfs(node.right, sum-node.val);
}

129. Sum Root to Leaf Numbers(sum of each path from root to leaf)
[medium] int = DFS(node, val)
public int dfs(TreeNode node, int sum){
    if(node == null) return 0;
    int ret = sum*10 + node.val;
    if(node.left == null && node.right==null) return ret;
    return dfs(node.left, ret) + dfs(node.right, ret);
}

257. Binary Tree Paths(return all root to leaf path)(real question)(facebook)
[easy-medium] DFS + backtracking. similar to N129. void = DFS(node, ret, string)

114. Flatten Binary Tree to Linked List(look again)
[medium-hard] return pre-order list
    public void flatten(TreeNode root) {
        if (root == null) return;

        TreeNode cur = root, prev;
        while (cur != null) {
            if (cur.left == null) cur = cur.right;
            else {
                prev = cur.left;

                while (prev.right != null) prev = prev.right;

                prev.right = cur.right;
                cur.right = cur.left;
                cur.left = null;
            }
        }
    }

222. Count Complete Tree Nodes (require o(nlogn) time) (interesting)
[medium] binary search.  int = dfs(node)
count left_height; count right_height; if equal return (1<<left_height)-1;
else recur(root.left) + recur(root.right) +1;
public int countNodes(TreeNode root) {
    if(root == null) return 0;
    TreeNode leftNode = root, rightNode=root;
    int left_height=0, right_height=0;
    while(leftNode != null){
        leftNode = leftNode.left;
        left_height++;
    }
    while(rightNode != null){
        rightNode = rightNode.right;
        right_height++;
    }
    if(left_height == right_height){
        return (1<<left_height) -1;
    }
    // left_height > right_height
    return countNodes(root.left) + countNodes(root.right) + 1;
}

226. Invert Binary Tree(swap left and right)(interesting)
[easy-medium] node = DFS(node), bottom up.
    if(root == null) return root;
    TreeNode tmp = invertTree(root.left);
    root.left = invertTree(root.right);
    root.right = tmp;
    return root;

236. Lowest Common Ancestor of a Binary Tree(real question)(Google/Microsoft)
[medium] top-bottom. kind of similar to N226.
if left and right children contains each of q and p, then return current node;
else if one of them is returned, then that one is the result.
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    if(root == null || root == p || root == q) return root;
    TreeNode left = lowestCommonAncestor(root.left, p, q);
    TreeNode right = lowestCommonAncestor(root.right, p, q);
    if(left != null && right!=null) return root;
    return right == null? left: right;
}

250. Count Univalue Subtrees(A Uni-value subtree means all nodes of the subtree have the same value.)
[medium] post-order traversal.


298. Binary Tree Longest Consecutive Sequence(The longest consecutive path need to be from parent to child)
[medium] pre-order traversal

314. Binary Tree Vertical Order Traversal
[medium] level-order traversal


331. Verify Preorder Serialization of a Binary Tree
[medium] diff = outdegree - indegree = 1. each node count--; if not leaf, count+=2;
public boolean isValidSerialization(String preorder) {
    String[] arr = preorder.split(",");
    int count = 1;
    for(String s: arr){
        if(--count <0) return false;
        if(!s.equals("#")) count+=2;
    }
    return count == 0;
}

*156. Binary Tree Upside Down(VIP)(linkedin phone)(interesting)
[medium] bottom-up(post-order), pass down parent. return dfs(root, null);
    public TreeNode dfs(TreeNode node, TreeNode parent){
        if(node == null) return parent; // return left-most node
        TreeNode root = dfs(node.left, node);
        node.left = (parent == null)? null: parent.right;
        node.right = parent;
        return root;
    }


366. Find Leaves of Binary Tree
[medium]

404. Sum of Left Leaves
[easy-medium] DFS.
public int sumOfLeftLeaves(TreeNode root) {
    if(root ==null) return 0;
    if(root.left != null && root.left.left ==null && root.left.right==null)
        return root.left.val + sumOfLeftLeaves(root.right);
    return sumOfLeftLeaves(root.left) + sumOfLeftLeaves(root.right);
}

508. Most Frequent Subtree Sum
[medium]

513. Find Bottom Left Tree Value
[medium] level-order

515. Find Largest Value in Each Tree Row
[medium] level-order




---------------------------------------------------
17.BST(Binary Search Tree)(reviewed on 9/30/2016, 10/28/2016, 9/6/2017)
---------------------------------------------------
538. Convert BST to Greater Tree
[]


653. Two Sum IV Input is a BST
[]


669. Trim a Binary Search Tree
[]



*96. Unique Binary Search Trees(return how many unique trees.)
[medium-hard] DP. catalan number. f(n) = f(0)*f(n-1) + f(1)*f(n-2) + ... + f(n-1)f(0)
public int numTrees(int n) {
    int[] catalan = new int[n+1];
    catalan[0]=1;
    for(int i=1; i<=n; i++){
        for(int j=0;j<i;j++){
            catalan[i] += catalan[j] * catalan[i-j-1];
        }
    }
    return catalan[n];
}

98. Validate Binary Search Tree(real question)(interesting)
[easy-medium]
1. DFS. pass along min, max value to validate. Can pass null to Integer to avoid overflow.
    public boolean isValid(TreeNode node, Integer low, Integer high){
        if(node == null) return true;
        return (low == null || low < node.val) && (high == null || node.val < high) &&
                isValid(node.left, low, node.val) && isValid(node.right, node.val, high);
    }
2. in-order traversal, compare preNode and curNode isMonotonicIncreasing, like N109 convert list to BST.


108. Convert Sorted Array to Binary Search Tree(real question)(interesting)
[easy] node = DFS(int[], left_index, right_index) (divide and conquer)
public TreeNode sortedArrayToBSTHelper2(int[] nums, int left, int right){
    if (left > right) return null;
    int mid = left + (right - left)/2;
    TreeNode node = new TreeNode(nums[mid]);
    node.left = sortedArrayToBSTHelper(nums, left, mid - 1);
    node.right = sortedArrayToBSTHelper(nums, mid + 1, right);
    return node;
}

*109. Convert Sorted List to Binary Search Tree(real question)(follow up of N108)
[medium] 1. convert list to array.  2. two pointers find mid point each loop.
3. global pointer, find length in one loop. see 109 solution. (bottom-up)  node = dfs(node, start_int, end_int)
private ListNode node ;
public TreeNode buildBST(int start, int end){
    if(start > end) return null;
    int mid = (end-start)/2 + start;
    TreeNode left = buildBST(start, mid-1);
    TreeNode root = new TreeNode(node.val);
    node = node.next;
    TreeNode right = buildBST(mid+1, end);
    root.left = left;
    root.right = right;
    return root;
}


230. Kth Smallest Element in a BST [favorite]
[medium] recursively count current node.
if k == count return; else if count > k, dfs(root.left,k); else dfs(root.right, k-count);
or iteratively in-order traversal.
class Solution {
    public int kthSmallest(TreeNode root, int k) {
        int count = dfs(root.left) + 1;
        if(count == k) return root.val;
        else if(count > k) return kthSmallest(root.left, k);
        else return kthSmallest(root.right, k - count);
    }
    public int dfs(TreeNode node){  // count nodes
        if(node == null) return 0;
        return dfs(node.left) + dfs(node.right) + 1;
    }
}

235. Lowest Common Ancestor of a Binary Search Tree
[easy] return if p < node.val < q. ; else recur left or right.
public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
    while(root!=null){
        if(root.val < p.val && root.val < q.val)       root = root.right;
        else if(root.val > p.val && root.val > q.val)  root = root.left;
        else return root;
    }
    return null;
}

255. Verify Preorder Sequence in Binary Search Tree
[medium] stack<val>.
simulate traversal, if incoming is smaller, then push,
if larger, pop all smaller and keep the popped as min, the incoming should larger than min or return false.

270. Closest Binary Search Tree Value(find the value in the BST that is closest to the target)
[easy]

272. Closest Binary Search Tree Value II(find k values in the BST that are closest to the target)
[medium]

285. Inorder Successor in BST
[medium]

333. Largest BST Subtree
[medium]


450. Delete Node in a BST
[medium]

501. Find Mode in Binary Search Tree
[medium]

530. Minimum Absolute Difference in BST
[medium] in-order


---------------------------------------------------
18.Augmented Tree(9/5/2017)
---------------------------------------------------
307. Range Sum Query - Mutable(real question)(google)(must)
[medium-hard] segment tree.
    public class SegmentTreeNode{
        int start, end, sum;
        SegmentTreeNode left, right;
    }

                     [0,5]
                   /       \
              [0,3]        [4,5]
             /    \        /   \
        [0,1]     [2,3]  [4,4] [5,5]
       /    \     /    \
    [0,0] [1,1] [2,2]  [3,3]


308. Range Sum Query 2D Mutable
[hard] fenwick tree. o(logmn)


315. Count of Smaller Numbers After Self
[medium] build BST.


440. Kth Smallest in Lexicographical Order
[medium] denary tree(10-children tree)

480. Sliding Window Median
[medium] treeset ?

---------------------------------------------------
19.BFS
---------------------------------------------------
286. Walls and Gates(Fill each empty room with the distance to its nearest gate)
[medium] BFS.

317. Shortest Distance from All Buildings
[medium] BFS with more variables to save information.

433. Minimum Genetic Mutation
[medium] BFS + map.

490. The Maze
[medium]

499. The Maze III
[medium]

505. The Maze II
[medium] BFS + heap

542. 01 Matrix
[medium] BFS

582. Kill Process
[]

623. Add One Row to Tree
[] BFS

675. Cut Off Trees for Golf Event
[] BFS + heap

---------------------------------------------------
20.DFS
---------------------------------------------------
329. Longest Increasing Path in a Matrix
[hard] DFS + memo

339. Nested List Weight Sum
[medium] DFS

364. Nested List Weight Sum II
[medium] DFS

473. Match sticks to Square
[medium] DFS

486. Predict the Winner
[hard]

488. Zuma Game
[medium]

494. Target Sum
[medium]

504. Base7
[easy] recursion

529. Mine sweeper
[medium]

544. Output Contest Matches
[medium] recursion.

546. Remove Boxes
[medium] DFS + memo

547. Friend Circles
[medium] DFS

564. Find the Closest Palindrome
[hard]

631. Design Excel Sum Formula
[] recursion


---------------------------------------------------
21.Divide and conquer(reviewed on 9/7/2017)
---------------------------------------------------
*95. Unique Binary Search Trees II(generate all unique trees)(interesting)
[medium-hard] DFS. foreach(start,n), left = (start,i-1), right=(i+1,n).
public List<TreeNode> generateTrees(int start, int end) {
    List<TreeNode> ret = new LinkedList<>();
    if(start > end){
        ret.add(null);
        return ret;
    }

    for(int i=start; i<=end; i++){
        List<TreeNode> lefts= generateTrees(start, i-1);
        List<TreeNode> rights= generateTrees(i+1, end);

        for(TreeNode left: lefts){
            for(TreeNode right: rights){
                TreeNode node = new TreeNode(i);
                node.left = left;
                node.right = right;
                ret.add(node);
            }
        }
    }
    return ret;
}

*241. Different Ways to Add Parentheses(return all possible results by group them differently. operators are ""+-*")(very interesting)
[medium-hard] List<Integer> = DFS(string)  (divide and conquer)  example: 2*3+5    similar to N95, unique binary search trees.
find each operator, divide it into two half.
    public List<Integer> diffWaysToCompute(String input) {
        List<Integer> ret = new ArrayList<Integer>();
        if(input ==null || input.length()==0) return ret;

        for(int i=0;i<input.length();i++){
            char c = input.charAt(i);
            if(!isOperater(c)) continue;

            List<Integer> left = diffWaysToCompute(input.substring(0,i));
            List<Integer> right = diffWaysToCompute(input.substring(i+1));

            for(int x: left){
                for(int y: right){
                    ret.add(getValue(x,y,c));
                }
            }
        }
        if(ret.isEmpty()) ret.add(Integer.valueOf(input));
        return ret;
    }


312. Burst Balloons(Find the maximum coins you can collect by bursting the balloons wisely)
[hard]

*395. Longest Substring with At Least K Repeating Characters(interesting)
[medium] divide on the first char which has count < k
    public int longestSubstring(String s, int k) {
        if(s.length() == 0 || k > s.length()) return 0;
        if(k==0) return s.length();
        int[] map = new int[128];
        char[] a = s.toCharArray();
        for(int i=0;i<a.length;i++) map[a[i]]++;

        int index =0;
        while(index<a.length && map[a[index]]>=k) index++;
        if(index == a.length) return a.length;  //return if all chars has at least K count

        //divide
        int left = longestSubstring(s.substring(0,index),k);
        int right = longestSubstring(s.substring(index+1),k);
        return Math.max(left, right);
    }

548. Split Array with Equal Sum
[medium]



---------------------------------------------------
22.Graph
---------------------------------------------------
261. Graph Valid Tree(check if graph is tree)
[medium] undirected. a valid tree means: all nodes are connected and there is no circle.
DFS only from one node, return false if find circle. return false if not all nodes are visited.

332. Reconstruct Itinerary
[hard] directed graph.

399. Evaluate Division
[hard]

444. Sequence Reconstruction
[medium] graph.

207. Course Schedule (find cycle in a graph)(interesting)
[medium-hard] boolean = canFinishDFS(node_int, map<node_int, adjacent_node_hashset_ofInt>, visitedNode_int_array)
// visited = 1, visiting= -1
private boolean canFinishDFS(HashMap<Integer, HashSet<Integer>> map,
                             int[] visited, int i) {
    if(visited[i] == -1) return false;
    if(visited[i] == 1) return true;  //pruning, means this node has confirmed without cycle.

    visited[i] = -1;
    if(map.containsKey(i)){
        for(int adjacent_node: map.get(i)){
            if(!canFinishDFS(map, visited, adjacent_node)) return false;
        }
    }
    visited[i] = 1;
    // ret[index--] = i;  // for N210
    return true;
}

210. Course Schedule II(return one possible route)
[medium-hard] graph. similar to N207,  not sure why it's  "ret[index--]=i;" for backtracking.
extra line see above


269. Alien Dictionary
[hard] graph, undirected.


---------------------------------------------------
23.Union Find
---------------------------------------------------
305. Number of Islands II(return number of islands after add some lands)
[medium] Union Find

323. Number of Connected Components in an Undirected Graph
[medium] Union Find.




---------------------------------------------------
24.Backtracking(better for shortest path)(reviewed on 10/3/2016 - 10/4/2016, 9/6/2017)
---------------------------------------------------
17. Letter Combinations of a Phone Number(return all possible letter combinations that the number could represent)
[medium] void = DFS(ret, cur_list, digits_string, start_int, map)
hashmap to map number and chars. DFS on each char.
String[] map = {"", "*", "abc", "def", "ghi", "jkl","mno", "pqrs", "tuv","wxyz"};

22. Generate Parentheses(given int n, return all combinations of well-formed parentheses)(interesting)
[medium] void = DFS(ret, cur_string, left_int, right_int)
return if left< right; add to ret if left==0 && right==0;
two DFS in func: dfs(cur+"(", left-1, right;  dfs(cur+")", left, right-1);

46. Permutations(Given a distinct collection of numbers, return all possible permutations)
[medium] void = DFS(ret, cur_list, num_array, used_array)

47. Permutations II (contains duplicates, return unique permutation, no duplicate set.)
[medium] dfs(int[] nums, boolean[] used, List<List<Integer>> ret, LinkedList<Integer> list)
Arrays.sort(num_array);
if(i>0 && num[i]==num[i-1] && !used[i-1]) continue; (think about why it's !used[i-1] for like set(1,1,2))

78. Subsets(Given a set of distinct integers, nums, return all possible subsets)
[medium] void = DFS(ret, cur_list, num_array, start_int)

90. Subsets II (contains duplicates)  [1,1,2]
[medium] dfs(List<List<Integer>> ret, int[] nums, List<Integer> cur_list, int start)
Arrays.sort(num_array);
if(i>start && num[i]==num[i-1]) continue;

// difference on permutation and subset, for example [1,2,3]:
permutation:   [1,2,3], [2,1,3] ...
subset:        [1,2,3], [2,3], [3] ...      subset remains original sequence.

// the reason why using start+1 or start is to avoid duplicate of (1,2) and (2,1).
// only permutation will need that, so it need an used_array.


39. Combination Sum(find all unique combinations in C where the candidate positive numbers sums to T) like set [3, 2, 6, 7] and target 7
[medium] void = DFS(ret, cur_list, num_array, cur_target, start_int); the same number can be used multiple times
dfs(ret, cur_list, num_array, cur_target-num_array[start_int], start_int);
Arrays.sort(num_array);

40. Combination Sum II (can use only once for each element.)
[medium] void = DFS(ret, cur_list, num_array, cur_target, start_int);
dfs(ret, cur_list, num_arary, cur_target-num_array[start_int], start_int+1); //key: start_int + 1 instead of start_int
Arrays.sort(num_array);

216. Combination Sum III(given number [1,9], each can use only once, return all possible k numbers sum to n)
[medium] void = DFS(ret, cur_list, k_int, n_int, start_int)
for(int i=start;i<=9;i++){}

377. Combination Sum IV(return number of possible results with the same proble of N216)(tricky, tailored for interview, (1,2) and (2,1) both are valid)
[medium] DP.  dp[i+n] += dp[i] if (i+n<=target)

77.  Combinations(return all combinations of k numbers out of n, (1,2) and (2,1) are duplicate)
[medium] void = DFS(ret, cur_list, k_int, n_int, start_int)  for(int i=start;i<=n;i++)
return when size==k. return part of the subsets problem. similar to

79. Word Search (Is this word exists in matrix)
[medium] boolean = DFS(matrix, word_string, start_int, i_int, j_int, visited_matrix)
4 recursive calls inside one function. need visited[][] as backtrack, conditional and boundary check.

93. Restore IP Addresses(given a string of digits, return all possible valid IP address.)
[medium] void = DFS(ret, cur_list, word_string, start_int, level_int)
    public void dfs(List<String> ret, String cur_string, String s, int start, int pos){
        if(pos == 4 ){
            if(start >= s.length()) ret.add(cur_string.substring(1));
            return;
        }
        for(int i=start; i<start+3 && i<s.length(); i++){
            String ip = s.substring(start, i+1);
            if(Integer.valueOf(ip)<=255){
                dfs(ret, cur_string+"."+ip, s, i+1, pos+1);

                if(Integer.valueOf(ip) == 0) break; // optimise skip something like 00, 01
            }
        }
    }

127. Word Ladder
[medium]  BFS, shortest path to a word. (can be further optimized)

126. Word Ladder II(find all the path) (worth revisit)
[hard]  BFS + backtracking. extra node class to store path info.
    class Node{
        String word;
        Node pre;
    }


130. Surrounded Regions(matrix with 'X' and 'O', set surrounded 'O' to 'X')
[medium] BFS all edge 'O', mark all their neighbours to 'P', then reset 'O' -> 'X',  'P' -> 'O'


133. Clone Graph(each node's label is unique)(tricky but interesting)(real question)
[medium]  NewNode = DFS(node, map<node, newNode>), simiar to N138 clone random linked list
return new_node if encountered to avoid duplicate, copy itself and copy its neighbors, recursively add its neighbors.
public UndirectedGraphNode dfs(UndirectedGraphNode node,
                               HashMap<Integer,UndirectedGraphNode> map){
    if(map.containsKey(node)) return map.get(node); // return copy of node
    UndirectedGraphNode newNode = new UndirectedGraphNode(node.label);
    map.put(node, newNode);
    for(UndirectedGraphNode n: node.neighbors){
        newNode.neighbors.add(dfs(n, map));
    }
    return newNode;
}

200. Number of Islands(matrix with 1(land) and 0(water), count number of islands, assume edges are water)(interesting)
[medium] void = DFS(matrix, i_int, j_int, visited_matrix)
DFS, for each cell(if not visited, islands++), do DFS on adjacent cells, and mark them as visited.

247. Strobogrammatic Number II(build all such number given length n)
[medium] dfs, build string inside out.

248. Strobogrammatic Number III(return count of such number in a range)
[medium] S1, similar to N247, build all strings in given length and filter out in a range.
S2. similar to N246, for each number in that range, decide if it's in that range.

254. Factor Combinations(interesting)
[medium] add(i, remain), remove(remain), dfs(remain), remove(i)
12
2*6 ->  2* dfs(6) -> 2* 2*3
3*4
every dfs start>= last start, made sure it's sorted.



291. Word Pattern II(Given a pattern and a string str, find if str follows the same pattern)
[hard] backtracking?

294. Flip Game II(determine if the starting player can guarantee a win, by take turns to flip two consecutive "++" into "--")
[medium] backtracking

320. Generalized Abbreviation
[medium] backtracking

351. Android Unlock Patterns
[medium]

419. Battleships in a Board
[medium-easy] DFS, the same as N200 number of islands.


310. Minimum Height Trees(given a tree-like graph, return a list of MHT root.)
[medium-hard] graph, BFS, remove all leaf node until remain node <=2 and return.
map<node, hashset<node>> to store graph, BFS,
remove leaf nodes until at most 2 nodes remains, enlist all edge==1, and bfs from them
    while(n>2){
        n -= ret.size();
        ArrayList<Integer> new_leafs= new ArrayList<>();
        for(int leaf_node: ret){
            int neighbor_node = map.get(leaf_node).iterator().next();
            map.get(neighbor_node).remove(leaf_node);   // remove edge
            if(map.get(neighbor_node).size() == 1) new_leafs.add(neighbor_node);
        }
        ret = new_leafs;
    }


*386. Lexicographical Numbers(Given an integer n, return [1,n] in lexicographical order, n=13; return [1,10,11,12,13,2,3,4,5,6,7,8,9])(interesting)
[medium] void = DFS(pre_num_int, n_int, ret)
public void dfs(int pre, int n, List ret){
    for(int i=0;i<=9;i++){
        int val = pre*10 + i;
        if(val > n) return;
        if(val > 0){
            ret.add(val);
            dfs(val, n, ret);
        }
    }
}

394. Decode String( s = "2[abc]3[cd]ef", return "abcabccdcdcdef".)(interesting)
[medium] recursion, dfs(str, index).
    public String dfs(String s, int start){
        if(start >= s.length()) return "";
        StringBuilder ret = new StringBuilder();
        int num = 0;
        for(i=start; i<s.length(); i++){
            char c= s.charAt(i);
            if(Character.isLetter(c)) ret.append(c);
            else if(Character.isDigit(c)) num = num*10 + c-'0';
            else if(c == '['){
                String insideStr = dfs(s, i+1);
                for(int j=0;j<num;j++) ret.append(insideStr);
                num = 0;
            }else if(c == ']') return ret.toString();
            else throw new IllegalArgumentException("Invalid input");
        }
        return ret.toString();
    }

401. Binary Watch
[easy-medium] two for loops
Integer.bitCount(i) + Integer.bitCount(j) == num or backtracking combine hour and minute to one array


417. Pacific Atlantic Water Flow(very interesting)
[medium] DFS. matrix, similar to N317 Shortest distance from all buildings
search from 4 edges and store (i,j) can be reached from both sides, need boolean[][] pacific, boolean[][] atlantic


464. Can I Win(can't reuse number)(TODO)
[medium-hard] DFS+backtracking+DP.


465. OptimalAccountBalancing
[medium] backtracking

491. Increasing Subsequences
[medium]

526. Beautiful Arrangement
[medium]


5. Longest Palindromic Substring(read question)(important)
[medium-hard] 1. BF is o(n^3).  2. Manacher's Algorithm is o(n). non-trivial.
3. for each i, call isPal(i,i) and isPal(i,i+1) o(n^2)
4. getPal(s,i,i) and getPal(s,i,i+1);  use this solution.
    for(int i=0;i<s.length();i++){
        String cur = isPal(s, i, i);
        if(cur.length() > ret.length()) ret = cur;

        cur = isPal(s, i, i+1);
        if(cur.length() > ret.length()) ret = cur;
    }
    return ret;

public String isPal(String s, int left, int right){
    while(left>=0 && right<s.length()){
        if(s.charAt(left) == s.charAt(right)){
            left--; right++;
        }else break;
    }
    return s.substring(left+1, right);
}

9. Palindrome Number(real question)
[easy-medium] 1. convert to string.
2. create div the same digits as number, use it to get left digit

125. Valid Palindrome
[easy-medium] consider case and special chars. two pointers start from left and right end.

131. Palindrome Partitioning(find all possible palindrome partitioning of s)
[medium-hard] DP+DFS+backtracking.
DP(n^2) to store all substring isPal, DFS+backtracking on all substring. (~ o(n!))

132. Palindrome Partitioning II(Return the minimum cuts needed for a palindrome partitioning of s)
[hard] similar solution as 131 will TLE. add another DP condition in isPal[][] dp. o(n^2)
DP cut[j] = min(cut[j], cut[i-1] + 1) inside a[i] == a[j] condition.

214. Shortest Palindrome(add chars in front of string to make it palindrome)(tricky)
[hard] String, recursive. prefix, suffix and middle. [TODO]

266. Palindrome Permutation(VIP)
267. Palindrome Permutation II(VIP)(real question)(Akamai)
[medium] return all valid permutation string.
backtracking, count each char to int[256], store mid char, build half of the string.
dfs(int[] map, List<String> ret, String s, int length, String mid){
    if(s.length() == length) return{ret.add(s + mid + reversed);}
    for(i in [0,255]){
        if(map[i]>0){
            map[i]--;
            dfs(map, ret, s+ (char)i, length, mid);
            map[i]++;
        }
    }
}


336. Palindrome Pairs
[hard] hashtable + divide conquer.
split each words str1 and str2, and check if isPal(str2) and reversed(str2) in map. [TODO]

409. Longest Palindrome(interesting)
[easy-medium] ret += (odd-1)

479. Largest Palindrome Product
[easy]



---------------------------------------------------
25.Design(reviewed on 10/27/2016, 9/6/2017)
---------------------------------------------------
534. Design Tiny URL
[]

535. Encodeand Decode Tiny URL
[medium]

588. Design In Memory File System
[]

635. Design Log Storage System
[]

642. Design Search Autocomplete System
[]

676. Implement Magic Dictionary
[]


157. Read N Characters Given Read4
158. Read N Characters Given Read4 II - Call multiple times
[medium]

170. Two Sum III - Data structure design
[medium] map<num, count> + list(num), find (target - num) in map

244. Shortest Word Distance II(return shortest distance between two words in list)
[medium] map<num, list_of_index>, two pointers to get distance

271. Encode and Decode Strings(Design an algorithm to encode a list of strings to a string)
[medium]

346. Moving Average from Data Stream
[easy]

348. Design Tic Tac Toe
[medium]

352. Data Stream as Disjoint Intervals
[medium]

353. Design Snake Game
[medium]

359. Logger Rate Limiter
[easy] map

362. Design Hit Counter
[medium]

385. Mini Parser(interesting)(constructed NestedInteger from String)
[medium-hard] stack to store each object.
if '[', add obj to stack,  if ',' || ']', add number to stack.peek() object, if ']', pop stack.

355. Design Twitter
[medium-hard] [TODO] a few hashmap, hashset and priorityQueue.

379. Design Phone Directory(VIP)
[medium] hashset(maintain non-available number) + linkedlist(maintain available number)

380. Insert Delete GetRandom O(1)
[medium] hashmap<val, index> + list<val>, swap last one with map.get(val) and remove

381. Insert Delete GetRandom O(1) - Duplicates allowed(similar to N380)
[hard] HashMap<val, set_of_index> + list<val>


432. All O one Data Structure
[medium]

146. LRU Cache(implement get and set function for least recently used cache)
[hard] [design] [hashtable + double linked list]
linkedlist to represent Least recently used:
1. current get/set element will be put at the head of linked list
2. remove tail element when need delete.
3. hashmap<Element, Node> to enable o(1) to get/set element and operate on the node according to 1 and 2.

460. LFU Cache
[medium]


----------------------  Iterator --------------------------
173. Binary Search Tree Iterator(next() return smallest in BST)(interesting)(stack)
[medium] push all left node to stack until the left most.
when pop, if node.right!=null, push all its left. It's o(1) time, because each element is visited only once.

251. Flatten 2D Vector
[medium]

281. ZigzagIterator
[medium]

284. Peeking Iterator(existing functions are iterator.next and iterator.hasNext; add a peek function)
[medium] the key is to cache(save) next element with element and isPeeked variables.

341. Flatten Nested List Iterator(interesting)(how to use polymorphism)
[medium] stack<Iterator<NestedInteger>>

604. Design Compressed String Iterator
[]
------------------------------------------------------------


----------------------  Trie --------------------------
208. Implement Trie (Prefix Tree)
[medium-hard] class Trie{Trie[] children; boolean isEnd;}
    class TrieNode{
        HashMap<Character, TrieNode> children;
        boolean isEnd;
    }

211. Add and Search Word - Data structure design
[medium-hard] BFS on trie of wildcard(.)


411. Minimum Unique Word Abbreviation
[hard] dfs + trie


425. Word Squares
[hard] backtracking + trie


648. Replace Words
[]

--------------------------------------------------------






---------------------------------------------------
26.Math(reviewed on 10/27/2016)
---------------------------------------------------
553. Optimal Division
[]

556. Next Greater Element 3
[]

573. Squirrel Simulation
[]

587. Erect the Fence
[medium] convex hull

592. Fraction Addition and Subtraction
[medium]gcd

593. Valid Square
[]

625. Minimum Factorization
[]

628. Maximum Product of Three Numbers
[]

634. Find the Derangement of An Array
[]

650. 2 Keys Keyboard
[]

651. 4 Keys Keyboard
[]

660. Remove 9
[]

672. Bulb Switcher II
[]



7. Reverse Integer(real question)
[easy-medium] ret = ret*10 + x%10; x/=10; overflow, negative, trailing zeros?

43. Multiply Strings
[medium] o(n^2), p1 = i+j; p2=i+j+1; sum = product + ret[p2]; ret[p1] += sum /10; ret[p2] = sum % 10;

60. Permutation Sequence.
[medium to hard] math, k / (n-1)! for current number,  k%(n-1)! for next iteration.

168. Excel Sheet Column Title(convert base 10 to base 26)
[easy-medium] construct from right to left, use mod first then divide. n-- to solve non-zero issue.

171. Excel Sheet Column Number(convert base 26 to base 10)
[easy] sum = sum *26 + (s.charAt(i)- 'A' + 1); for(i in [0,n-1])

172. Factorial Trailing Zeroes
[easy] count number of 5s, equal trailing zeros. time o(log5)
while(n>0){
    n = n/5;
    ret += n;
}

223. Rectangle Area
[easy-medium] overlap(sum of 2 separate - overlap area) vs non-overlap(sum of 2 separate area).

258. Add Digits
[easy] digital root. ret = n%9; if ret==0; return 9;

263. Ugly Number[code is N262](only has factor of 2,3,5)
[easy] while loop (n/=5, n/=3, n/=2) return n==1;

264. Ugly Number II(interesting)(return nth ugly number)
[medium] DP. maintain l1, l2, l3 in dp[], next k =  min(dp[l1]*2, dp[l2]*3, dp[l3]*5);

313. Super Ugly Number
[medium-hard] similar to N264, more generalized.

292. Nim Game(grab 1-3 stones, grab the last one win, you take the first grab.)
[easy] you lose only when remains 4*n;

319. Bulb Switcher
[medium] return (int)Math.sqrt(n);

231. Power of Two(use bit)
[easy] return n>0 && (n & n-1) == 0;

326. Power of Three
[easy] recursively divide 3.

342. Power of Four
[easy] recursively divide 4.

343. Integer Break
[easy-medium] choose from [0,2] of 2, the rest should be 3.

357. Count Numbers with Unique Digits
[medium] f(k) = 9 * 9 * 8 * ... (9 - k + 2) [TODO]

365. Water and Jug Problem
[medium] return z % gcd(x,y) == 0; gcd{while (b!=0){ a=b; b=a%b} return a; }

367. Valid Perfect Square(9=1+3+5 ...)(interesting)
[medium] tmp=1; while(num>0) num -= tmp; tmp+=2; return num==0;

369. Plus One Linked List
[medium] stack.

372. Super Pow
[medium-hard] stack and recursion. kind of math, a^25 = (a^2)^10 * a^5;

390. Elimination Game
[medium-hard] move head only when 1. move from left, 2 move from right when remain is odd.
each time step *=2; remain /=2;

396. Rotate Function
[easy-medium] math.
Sum=f0+f1+...fn
F0 = 0*f0 + 1*f1 + n*fn
F1 = F0 + sum - n*f(n-1)
...

400. Nth Digit
[medium]

413. Arithmetic Slices
[medium] math. i in [2,n){cur +=1; ret += cur;} else cur=0;

423. Reconstruct Original Digits from English
[medium] find pattern.

441. Arranging Coins
[easy-medium] math or binary search.

453. Minimum Moves to Equal Array Elements
[easy-medium] think from the opposite way, add n-1 == minus 1;  ret= sum_of_array - n*min;


458. Poor Pigs
[easy] math.


462. Minimum Moves to Equal Array Elements II
[medium] math. sort and while(i<j) ret += nums[j--] - nums[i++];


469. Convex Polygon
[medium] geometry.


492. Construct the Rectangle
[easy]


507. Perfect Number
[easy]

517. Super Washing Machines
[hard]




---------------------------------------------------
27.Bit Manipulation(reviewed on 10/27/2016)
---------------------------------------------------
29. Divide Two Integers
[medium] not sure. [TODO]

371. Sum of Two Integers
[easy-medium] [TODO]  not sure why.

89. Gray Code(interesting)
[medium] f(n) += reverse(f(n-1)) + 2^(n-1), use list to represent f(n)

136. Single Number(one number appears once while others twice)(real question)
[easy]
1. map<num, count>, two passes. o(n) space
2. hashset<num>, remove char if exist. one pass. o(n) space
3. o(1) space and one pass. xor on all the elements.

[follow up](all exists twice except two, return those two)(interesting)
[medium] divide and conquer.
first pass, c ^= each item in array.
find any one bit in C that is 1 and store it, separate array to two groups(based on 0 and 1 on that bit)
xor all item in each group will get you those two int.

137. Single Number II(one number appears once while others three times)(real question)
[medium] on every bit, the sum of each bit is 3*n + (0 or 1). each bit mod 3 is the result.

260. Single Number III
[medium] two passes. two groups divided by one bit.

268. Missing Number(for [o,n] range, only one is missing, index in range [0,n-1])
[easy-medium] xor.  a^b^b = a.  ret = n(important); for i in [0,num.length) ret = ret ^ index ^ num[index]

190. Reverse Bits(unsigned integer) (follow up, hashtable to handle visited ones.)
[easy] ret = 0;
for(int i=0;i<32;i++){
    ret = ret<< 1 || (n & 1); n >>= 1  // the first bit is 0, so ok.
}

191. Number of 1 Bits
[easy] ret += (n & 1);  n >>= 1

201. Bitwise AND of Numbers Range(interesting) in range [m,n]
[easy-medium] count left common bits between m and n. return m<<count. write an example will understand.

397. Integer Replacement
[medium] matters on last two binary digits, and special case on 3.

405. Convert a Number to Hexadecimal(interesting)
[easy-medium] ret.insert(0, hex[num & 15]);

421. Maximum XOR of Two Numbers in an Array
[medium-hard] [TODO] figure out how this works.

461. Hamming Distance
[easy] xor. return Integer.bitCount(x^y);

476. Number Complement
[easy]

477. Total Hamming Distance
[medium]






-----------------------------------------[hard]---------------------------------------------
149. Max Points on a Line(Given n points on a 2D plane, find the maximum number of points that lie on the same straight line)
[hard-medium] [hashtable+corner cases]time o(n^2). for each point, calculate slope for each pair and store in map<slope_double, count_int>;
corner case of duplicate points(b.x==a.x && b.y==a.y) and vertical points (b.x==a.x)


65. Valid Number
[hard] skip white space, sign, digits, point, digits, e, reset hasNumber, skip sign, digits, space.
return hasNumber && i==n;

68. Text Justification
[hard] [String] [TODO reduce code length]

44. Wildcard Matching(string match but support '?' and '*')
[hard] [string] time o(n). compare with N28 strstr. [TODO]

10. Regular Expression Matching('.' match single char, while '*' should match zero or more preceding chars.)
[hard] [DFS or DP] (tricky to write, hard to prove correctness.) [TODO]

4. Median of Two Sorted Arrays
[hard] [binary search] [tricky]  [TODO]

273. Integer to English Words
[hard] [String] [long code] [TODO reduce code length]

212. Word Search II
[hard] [TODO may need to move close to word search]

30. Substring with Concatenation of All Words(seem to be interesting)
[hard] [2 hashtable] [TODO]

174. Dungeon Game(return min number needed to reach from top left to bottom right. Matrix contains both positive and negative number, need at least 1 in each cell)
[hard-medium] Bottom-up DP.

32. Longest Valid Parentheses(given a string contains only '(' and ')', return length of longest well-formed parentheses substring)(interesting)
[hard] [stack to store index! ] [TODO]

295. Find Median from Data Stream
[hard-medium] [2 heaps]
Queue minHeap = new PriorityQueue<Integer>((o1,o2)-> o1-o2); maxHeap= ...(o2-o1);
minHeap.add(num); maxHeap.add(min.poll()); if (maxHeap.size > minHeap.size) minHeap.add(maxHeap.poll);

135. Candy(higher rating kids should get more candy than its neighbors in an array, each has at least one)(interesting)
[hard-medium] two pass DP. init set all dp[i]=1;
1 pass left to right: dp[i] = dp[i-1]+1 if(rating[i]> rating[i-1])
2 pass right to left: similar to first pass.

97. Interleaving String
[hard] matrix DP. [TODO]

41. First Missing Positive(require o(n) time and o(1) space)
[hard] kind of inplace swap to its position. [TODO]


85. Maximal Rectangle(problem similar to N221 Maximal Square, but can't use DP)
[hard] convert matrix to n rows of histogram, and use N84 solution to find max in each row.

23. Merge k Sorted Lists(real question)
[hard-medium] o(nlogk)
1. o(k) space, Heap to store k node. heap = new PriorityQueue<ListNode>((o1,o2)->o1.val - o2.val);
2. o(1) space, divide and conquer, merge 2 lists recursively.

138. Copy List with Random Pointer(return deep copy)(real question)(interesting)
[hard-medium]
1. o(n) space, map<node, new_node>; 1st pass to copy next node, 2ed pass to copy random node using map.
2. o(1) space, copy each node and added to its next, as A->A'->B->B'; node.next.random = node.random.next;

233. Number of Digit One
[hard] [math] [TODO]

37. Sudoku Solver(solve a sodoku in matrix, assume there is only one solution)
[hard-medium] DFS+backtracking.  void = DFS(matrix, seq_int)
for each cell if empty, DFS(matrix, seq_int+1);

282. Expression Add Operators(return all possible expression with added operators(+-*) equals target)
[hard] DFS+backtracking+Divide Conquer+Math.  void = DFS(ret, cur_str, num_string, target_int, start_int, sum_int, last_sum_int)
public void dfs(List<String> ret, String num, int target, String path, int pos, long sum, long lastNum){
    if(pos == num.length()){
        if(sum == target) ret.add(path);
        return;
    }
    for(int i=pos; i<num.length();i++){
        if(num.charAt(pos) == '0' && pos != i) break; // skip corner case like 000
        long cur = Long.parseLong(num.substring(pos,i+1));
        if(pos == 0) dfs(ret, num, target, path + cur, i+1, cur, cur);//first num, has to be i+1
        else{
            dfs(ret, num, target, path + "+" + cur, i+1, sum+cur, cur);
            dfs(ret, num, target, path + "-" + cur, i+1, sum-cur, -cur);
            dfs(ret, num, target, path + "*" + cur, i+1, sum-lastNum + lastNum*cur, lastNum*cur);
        }
    }
}

316. Remove Duplicate Letters(return unique lexicographical order)
[hard] count each char and stack.  [TODO]

87. Scramble String(test if two string are scramble of each other)
[hard] Divide and conquer + DFS.  boolean = DFS(str1, str2)  [TODO explore DP solution]
s1_1=s1.substring(0,i);  s1_2=s1.substring(i,n);
s2_1=21.substring(0,i);  s2_2=s2.substring(i,n);
if (dfs(s1_1, s2_1) && dfs(s1_2,s2_2)) return true;
s2 from right side, s3_1 = s2.substring(n-i,n) s3_2 = s2.substring(0,n-i);
if (dfs(s1_1, s3_1) && dfs(s1_2,s3_2)) return true;

51. N-Queens(return all possible matrix solution)
[hard] similar to N52, just need to build matrix.

52. N-Queens II(return number of possible solution)
[hard-medium] void =  DFS(n_int, row_int, visited_cols_list)
// if i and j in diagonal, ab(i_row - j_row) == ab(i_col - j_col)
public boolean isValidPosition(int row_index, int col_index, List<Integer> visited_cols){
    for(int i=0;i<visited_cols.size();i++){
        if(col_index == visited_cols.get(i) || Math.abs(row_index - i) == Math.abs(col_index - visited_cols.get(i)))
            return false;
    }
    return true;
}

164. Maximum Gap(return max difference between two neighbors in sorted form)(interesting)
[hard] BF. o(nlogn) sorted array, and gap = max(gap, a[i]-a[i-1]);
require o(n) time, bucket sort, at most (max-min)/len + 1 buckets. (TODO)

99. Recover Binary Search Tree(Two elements of a binary search tree (BST) are swapped by mistake, recover it.)
[hard] BF is o(n) space. save node to list, and sort values and reassign to each node.
o(1) space. morris traversal.  (TODO)

25. Reverse Nodes in k-Group(reverse k linked list node at a time)
[hard-medium] reverse part of linked list.

72. Edit Distance(return min steps to convert str1 to str2, 3 allowed operations: add, delete, replace)
[hard] matrix DP.  dp[0][i] = 1 and dp[i][0]=1; if c1 = c2; dp[i+1][j+1] = dp[i][j];
else  dp[i+1][j+1] = min(dp[i][j], dp[i+1][j], dp[i][j+1]) + 1;

239. Sliding Window Maximum(return an array of the max value in each k windows)(very interesting)
[hard] BF. time o(k*(n-k)), space o(1).  Find max in each K windows for (n-k) times.
o(n) time, but space o(k).  Deque<Integer> deque = new ArrayDeque<>();
use keep a descending deque of [1,k] elements, get max from the first. similar to min stack problem.
for(int i=0; i<nums.length;i++){
    // remove the first if out of range k
    if(!deque.isEmpty() && deque.peek() < i+1-k){
        deque.removeFirst();
    }
    // pop last if less than coming in
    while(!deque.isEmpty() && nums[deque.peekLast()] < nums[i]){
        deque.removeLast();
    }
    deque.addLast(i);
    if(i >= k-1){
        ret[ret_index++] = nums[deque.peek()];
    }
}

115. Distinct Subsequences(not sure the problem. [TODO])
[hard] 2D DP. dp[i][j] = dp[i-1][j];  if(s.charAt(i-1) == t.charAt(j-1)) dp[i][j] += dp[i-1][j-1];

297. Serialize and Deserialize Binary Tree(very interesting)
[hard-medium] Serialize: recursively preorder traversal node to store each node in String separated by ',';
Deserialize: split string by ',' to a list, recursively build tree back.
public TreeNode deserialize(LinkedList<String> list){
    String cur = list.removeFirst();
    if(cur.equals("null")) return null;

    TreeNode node = new TreeNode(Integer.valueOf(cur));
    node.left = deserialize(list);
    node.right = deserialize(list);
    return node;
}

449. Serialize and Deserialize BST
[medium] the same as N297.


354. Russian Doll Envelopes(return max doll you can fit in, need a.length > b.length && a.width>b.width)
[hard] DP time o(n^2), sort, similar to longest increasing sequence.  dp[j] = max(dp[j], dp[i] + 1);
public int maxEnvelopes(int[][] envelopes) {
    if(envelopes.length == 0) return 0;
    Arrays.sort(envelopes, (int[] a,int[] b)->(a[0] == b[0]?a[1]-b[1]:a[0]-b[0]));
    int[] dp = new int[envelopes.length];
    Arrays.fill(dp,1);
    int max = 1;
    for(int j=1;j<envelopes.length;j++){
        for(int i=0;i<j;i++){
            if(envelopes[j][0]>envelopes[i][0] && envelopes[j][1] > envelopes[i][1]){
                dp[j] = Math.max(dp[j], dp[i] + 1);
            }
        }
        max = Math.max(dp[j], max);
    }
    return max;
}
[TODO] Binary search o(nlogn)?

301. Remove Invalid Parentheses(return all valid results after remove invalid ones)
[hard] DFS or BFS. (TODO)

128. Longest Consecutive Sequence(return max length of consecutive sequence in array. like 1,2,3,4 ...)(interesting and impressive)
[hard-medium] require o(n) time. hashset.
put all num in hashset; go through each item in hashset and iterate through it's left and right, update max and remove them to prune.

42. Trapping Rain Water(return how much water can be trapped in the whole array)(interesting)
[hard-medium] 2 passes DP.
leftMostHeight[i] = Math.max(leftMostHeight[i-1], height[i-1]);
rightMostHeight[i] = Math.max(rightMostHeight[i+1], height[i+1]);
ret += max(Math.min(leftMostHeight[i], rightMostHeight[i]) - height[i] , 0)

287. Find the Duplicate Number(find the duplicate one in array with size n+1, but numbers are range [1,n])
[hard] require o(1) space, can't modify array, running time faster than o(n^2)
BF, time o(n^2) compare each number.
tricky solution, map of map. (TODO)

410. Split Array Largest Sum
[hard] binary search, but hard to prove it's right.(TODO)


420. Strong Password Checker
[hard] look again.











